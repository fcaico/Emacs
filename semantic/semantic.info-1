This is semantic.info, produced by makeinfo version 4.0 from
semantic.texi.

START-INFO-DIR-ENTRY
* semantic: (semantic).       Semantic Parsing for Emacs
END-INFO-DIR-ENTRY


File: semantic.info,  Node: Top,  Next: Install,  Prev: (dir),  Up: (dir)

   Semantic is a program for Emacs which includes, at its core, a lexer,
and a compiler compiler (bovinator).  Additional tools include a
bnf->semantic table converter, example tables, and a speedbar tool.

   The core utility is the "semantic bovinator" which has similar
behaviors as yacc or bison.  Since it is not designed to be as feature
rich as these tools, it uses the term "bovine" for cow, a lesser cousin
of the yak and bison.

   In it's current state, the bovinator is both fast (because it uses
Emacs tricks) and slow (it is recursive, and not table (array) based).
If you have experience with compiler compilers (bison, yacc, etc) your
help to make these updates would be greatly appreciated.

* Menu:

* Install::                     Installing semantic.
* Lexing::                      Setting up the lexer for your language.
* Bovinating::                  Setting up the parser for your language.
* BNF conversion::              Using the BNF converter to make tables.
* Compiling::                   Running the bovinator on a source file.
* Debugging::                   Debugging bovine tables
* Utilities::                   How to use the nonterminal stream.
* Current Context::             How to get the current code context.
* Tools::                       User Tools which use semantic.
* Index::


File: semantic.info,  Node: Install,  Next: Lexing,  Prev: Top,  Up: Top

Installation
************

   To install semantic, untar the distribution into a subdirectory,
such as `/usr/share/emacs/site-lisp/semantic-#.#'.  Next, add the
following lines into your individual `.emacs' file, or into
`site-lisp/site-start.el'.

     (setq semantic-load-turn-everything-on t)
     (load-file "/path/to/semantic/semantic-load.el")

   If you would like to turn individual tools on or off in your init
file, skip the first line.


File: semantic.info,  Node: Lexing,  Next: Bovinating,  Prev: Install,  Up: Top

Preparing your language for Lexing
**********************************

   In order to reduce a source file into a token list, it must first be
converted into a token stream.  Tokens are syntactic elements such as
whitespace, symbols, strings, lists, and punctuation.

   The lexer uses the major-mode's syntax table for conversion.  As long
as that is set up correctly (along with the important `comment-start'
and `comment-start-skip' variable) the lexer should already work for
your language.

   There are three ways to extend the lexer.

 - Variable: semantic-flex-extensions
     Buffer local extensions to the lexical analyzer.  This should
     contain an alist with a key of a regex and a data element of a
     function.  The function should both move point, and return a
     lexical token of the form:

          ( TYPE START . END)

     `nil' is also a valid return.  TYPE can be any type of symbol, as
     long as it doesn't occur as a nonterminal in the language
     definition.

 - Variable: semantic-flex-syntax-modifications
     Updates to the syntax table for a given buffer.  These changes are
     active only while this file is being flexed.  This is a list where
     each element is of the form:
          (CHAR CLASS)

     Where CHAR is the char passed to `modify-syntax-entry', and CLASS
     is the string also passed to `modify-syntax-entry' to define what
     class of syntax CHAR is.

          (setq semantic-flex-syntax-modifications '((?. "_"))

     Will convert the period . to be a symbol constituant.  (ie, if
     filenames are prevalent as in Makefiles.)

 - Variable: semantic-flex-enable-newlines
     When flexing, report `'newlines' as syntactic elements.  Useful
     for languages where the newline is a special case terminator.
     Only set this on a per mode basis, not globally.

Keywords
========

   Another important piece of the lexer is the keyword table. *Note
Settings::.  You language will want to set up a keyword table for fast
conversion of symbol strings to language terminals.

   The keywords table can also be used to store additional information
about those keywords.  The following programming functions can be useful
when examining text in a language buffer.

 - Function: semantic-flex-keyword-p text
     Return a symbol if TEXT is a keyword in the keyword table.

 - Function: semantic-flex-keyword-put text property value
     For keyword TEXT, set PROPERTY to have VALUE.

 - Function: semantic-flex-keyword-get text property
     For the keyword found as TEXT, get the value of PROPERTY.

 - Function: semantic-flex-map-keywords fun &optional property
     Call function FUN on every semantic keyword.  If optional PROPERTY
     is non-nil call FUN only on every keyword which have a PROPERTY
     value.  FUN receives a semantic keyword as argument.

 - Function: semantic-flex-keywords &optional property
     Return a list of semantic keywords.  If optional PROPERTY is
     non-nil return only keyword which have a PROPERTY value.

   Keyword properties can be set up in a BNF file for ease of
maintenance.  While examining the text in a language buffer, this can
provide an easy and quick way of storing details about text in the
buffer.

Standard Keyword Properties
===========================

   Add known properties here when they are known.


File: semantic.info,  Node: Bovinating,  Next: BNF conversion,  Prev: Lexing,  Up: Top

Preparing a bovine table for your language
******************************************

   When converting a source file into a nonterminal token stream
(parse-tree) it is important to specify rules to accomplish this.  The
rules are stored in the buffer local variable
`semantic-toplevel-bovine-table'.

   While it is certainly possible to write this table yourself, it is
most likely you will want to use the BNF converter.  *Note BNF
conversion::.  This is an easier method for specifying your rules.  You
will still need to specify a variable in your language for the table,
however.  A good rule of thumb is to call it
`language-toplevel-bovine-table' if it part of the language, or
`semantic-toplevel-language-bovine-table' if you donate it to the
semantic package.

   When initializing a major-mode for your language, you will set the
variable `semantic-toplevel-bovine-table' to the contents of your
language table.  `semantic-toplevel-bovine-table' is always buffer
local.

   Since it is important to know the format of the table when debugging
, you should still attempt to understand the basics of the table.

   Please see the documentation for the variable
`semantic-toplevel-bovine-table' for details on it's format.

   * add more doc here *


File: semantic.info,  Node: BNF conversion,  Next: Compiling,  Prev: Bovinating,  Up: Top

Using the BNF converter to make bovine tables
*********************************************

   The BNF converter takes a file in "Bovine Normal Form" which is
similar to "Backus-Naur Form".  If you have ever used yacc or bison,
you will find it similar.  The BNF form used by semantic, however, does
not include token precedence rules, and several other features needed
to make real parser generators.

   It is important to have an Emacs Lisp file with a variable ready to
take the output of your table *Note Bovinating::.  Also, make sure that
the file `semantic-bnf.el' is loaded.  Give your language file the
extension `.bnf' and you are ready.

   The comment character is #.

   When you want to test your file, use the keyboard shortcut `C-c C-c'
to parse the file, generate the variable, and load the new definition
in.  It will then use the settings specified above to determine what to
do.  Use the shortcut `C-c c' to do the same thing, but spend extra
time indenting the table nicely.

   Make sure that you create the variable specified in the
`%parsetable' token before trying to convert the bnf file.  A simple
definition like this is sufficient.

     (defvar semantic-toplevel-lang-bovine-table
        nil
        "Table for use with semantic for parsing LANG.")

   If you use tokens (created with the `%token' specifier), also make
sure you have a keyword table available, like this:

     (defvar semantic-lang-keyword-table
        nil
        "Table for use with semantic for keywords.")

   Specify the name of the keyword table with the `%keywordtable'
specifier.

   The BNF file has two sections.  The first is the settings section,
and the second is the language definition, or list of semantic rules.

* Menu:

* Settings::
* Rules::
* Optional Lambda Expression::
* Examples::


File: semantic.info,  Node: Settings,  Next: Rules,  Prev: BNF conversion,  Up: BNF conversion

Settings
========

   A setting is a keyword starting with a %.  (This syntax is taken
from yacc and bison. *Note (bison)::.)

   There are several settings that can be made in the settings section.
They are:

`%start <nonterminal>'
     Specify an alternative to `bovine-toplevel'.  (See below)

`%scopestart <nonterminal>'
     Specify an alternitive to `bovine-inner-scope'.

`%outputfile <filename>'
     Required.  Specifies the file into which this files output is
     stored.

`%parsetable <lisp-variable-name>'
     Required.  Specifies a lisp variable into which the output is
     stored.

`%keywordtable <lisp-variable-name>'
     Required if there are `%token' keywords.  Specifies a lisp
     variable into which the output of a keyword table is stored.  This
     obarray is used to turn symbols into keywords when applicable.

`%token <name> "<text>"'
     Optional.  Specify a new token NAME.  This is added to a lexical
     keyword list using TEXT.  The symbol is then converted into a new
     lexical terminal.  This requires that the `%keywordtable' specified
     variable is available in the file specified by `%outputfile'.

`%token <name> type "<text>"'
     Optional.  Specify a new token NAME.  It is made from an existing
     lexical token of type TYPE.  TEXT is a string which will be
     matched explicitly.  NAME can be used in match rules as though
     they were flex tokens, but are converted back to TYPE "text"
     internally.

`%put <NAME> symbol <VALUE>'
`%put <NAME> ( symbol1 <VALUE1> symbol2 <VALUE2> ... )'
`%put ( <NAME1> <NAME2>...) symbol <VALUE>'
     Tokens created without a type are considered keywords, and placed
     in a keyword table.  Use `%put' to apply properties to that
     keyword.  *Note Lexing::.

`%languagemode <lisp-function-name>'
`%languagemode ( <lisp-function-name1> <lisp-function-name2> ... )'
     Optional.  Specifies the Emacs major mode associated with the
     language being specified.  When the language is converted, all
     buffers of this mode will get the new table installed.

`%quotemode backquote'
     Optional.  Specifies how symbol quoting is handled in the Optional
     Lambda Expressions. (See below)

`%setupfunction <lisp-function-name>'
     Name of a function into which setup code is to be inserted.

`%( <lisp-expression> )%'
     Specify setup code to be inserted into the `%setupfunction'.  It
     will be inserted between two specifier strings, or added to the
     end of the function.

   When working inside `%( ... )%' tokens, any lisp expression can be
entered which will be placed inside the setup function.  In general, you
probably want to set variables that tell Semantic and related tools how
the language works.

   Here are some variables that control how different programs will work
with your language.

 - Variable: semantic-flex-depth
     Default flexing depth.  This specifies how many lists to create
     tokens in.

 - Variable: semantic-flex-extensions
     Buffer local extensions to the lexical analyzer.  This should
     contain an alist with a key of a regex and a data element of a
     function.  The function should both move point, and return a
     lexical token of the form:
          ( TYPE START . END)

     `nil' is also a valid return.  TYPE can be any type of symbol, as
     long as it doesn't occur as a nonterminal in the language
     definition.

 - Variable: semantic-flex-syntax-modifications
     Updates to the syntax table for this buffer.  These changes are
     active only while this file is being flexed.  This is a list where
     each element is of the form:
          (CHAR CLASS)
     Where CHAR is the char passed to "modify-syntax-entry", and CLASS
     is the string also passed to "modify-syntax-entry" to define what
     class of syntax CHAR is.

 - Variable: semantic-flex-enable-newlines
     When flexing, report `'newlines' as syntactic elements.  Useful
     for languages where the newline is a special case terminator.
     Only set this on a per mode basis, not globally.

 - Variable: semantic-ignore-comments
     Default comment handling.  `t' means to strip comments when
     flexing.  `Nil' means to keep comments as part of the token stream.

 - Variable: semantic-symbol->name-assoc-list
     Association between symbols returned, and a string.  The string is
     used to represent a group of objects of the given type.  It is
     sometimes useful for a language to use a different string in place
     of the default, even though that language will still return a
     symbol.  For example, Java return's includes, but the string can
     be replaced with `Imports'.

 - Variable: semantic-case-fold
     Value for `case-fold-search' when parsing.

 - Variable: semantic-expand-nonterminal
     Function to call for each nonterminal production.  Return a list
     of non-terminals derived from the first argument, or `nil' if it
     does not need to be expanded.  Languages with compound definitions
     should use this function to expand from one compound symbol into
     several.  For example, in C the definition
          int a, b;
     is easily parsed into one token, but represents multiple
     variables.  A functions should be written which takes this
     compound token and turns it into two tokens, one for A, and the
     other for B.

     Within the language definition (the `.bnf' sources), it is often
     useful to set the NAME slot of a token with a list of items that
     distinguish each element in the compound definition.

     This list can then be detected by the function set in
     `semantic-expand-nonterminal' to create multiple tokens.  This
     function has one additional duty of managing the overlays created
     by semantic.  It is possible to use the single overlay in the
     compound token for all your tokens, but this can pose problems
     identifying all tokens covering a given definition.

     Please see `semantic-java.el' for an example of managing overlays
     when expanding a token into multiple definitions.

 - Variable: semantic-override-table
     Buffer local semantic function overrides alist.  These overrides
     provide a hook for a `major-mode' to override specific behaviors
     with respect to generated semantic toplevel nonterminals and
     things that these non-terminals are useful for.  Each element must
     be of the form: (SYM . FUN) where SYM is the symbol to override,
     and FUN is the function to override it with.

     Available override symbols:

     SYBMOL                     PARAMETERS          DESCRIPTION
     find-dependency            (token)             Find the dependency
                                                    file
     find-nonterminal           (token & parent)    Find token in buffer.
     find-documentation         (token & nosnarf)   Find doc comments.
     abbreviate-nonterminal     (token & parent)    Return summery string.
     summarize-nonterminal      (token & parent)    Return summery string.
     prototype-nonterminal      (token)             Return a prototype
                                                    string.
     prototype-file             (buffer)            Return a file in
                                                    which prototypes are
                                                    placed
     nonterminal-children       (token)             Return first rate
                                                    children. These are
                                                    children which may
                                                    contain overlays.
     nonterminal-protection     (token & parent)    Return protection as
                                                    a symbol.
     beginning-of-context       (& point)           Move to the beginning
                                                    of the
                                                     current context.
     end-of-context             (& point)           Move to the end of the
                                                    current context.
     up-context                 (& point)           Move up one context
                                                    level.
     get-local-variables        (& point)           Get local variables.
     get-all-local-variables    (& point)           Get all local
                                                    variables.
     get-local-arguments        (& point)           Get arguments to this
                                                    function.
     end-of-command                                 Move to the end of
                                                    the current
                                                      command
     beginning-of-command                           Move to the beginning
                                                    of the
                                                    current command
     ctxt-current-symbol        (& point)           List of related
                                                    symbols.
     ctxt-current-assignment    (& point)           Variable being
                                                    assigned to.
     ctxt-current-function      (& point)           Function being called
                                                    at point.
     ctxt-current-argument      (& point)           The index to the
                                                    argument of
                                                      the current
                                                    function the cursor
                                                              is in.

     Parameters mean:

    `&'
          Following parameters are optional

    `buffer'
          The buffer in which a token was found.

    `token'
          The nonterminal token we are doing stuff with

    `parent'
          If a TOKEN is stripped (of positional infomration) then this
          will be the parent token which should have positional
          information in it.


 - Variable: semantic-type-relation-separator-character
     Character strings used to separation a parent/child relationship.
     This list of strings are used for displaying or finding separators
     in variable field dereferencing.  The first character will be used
     for display.  In C, a type field is separated like this:
     "type.field" thus, the character is a ".".  In C, and additional
     value of "->" would be in the list, so that "type->field" could be
     found.

 - Variable: semantic-dependency-include-path
     Defines the include path used when searching for files.  This
     should be a list of directories to search which is specific to the
     file being included.  This variable can also be set to a single
     function.  If it is a function, it will be called with one
     arguments, the file to find as a string, and  it should return the
     full path to that file, or nil.

   This configures Imenu to use semantic parsing.

 - Variable: imenu-create-index-function
     The function to use for creating a buffer index.

     It should be a function that takes no arguments and returns an
     index of the current buffer as an alist.

     Simple elements in the alist look like `(INDEX-NAME .
     INDEX-POSITION)'.  Special elements look like `(INDEX-NAME
     INDEX-POSITION FUNCTION ARGUMENTS...)'.  A nested sub-alist
     element looks like (INDEX-NAME SUB-ALIST).  The function
     `imenu--subalist-p' tests an element and returns t if it is a
     sub-alist.

     This function is called within a `save-excursion'.

     The variable is buffer-local.

   These are specific to the document tool.

`document-comment-start'
     Comment start string.

`document-comment-line-prefix'
     Comment prefix string.  Used at the beginning of each line.

`document-comment-end'
     Comment end string.


File: semantic.info,  Node: Rules,  Next: Optional Lambda Expression,  Prev: Settings,  Up: BNF conversion

Rules
=====

   Writing the rules should be very similar to bison for basic syntax.
Each rule is of the form

     RESULT : MATCH1 (optional-lambda-expression)
            | MATCH2 (optional-lambda-expression)
            ;

   RESULT is a non-terminal, or a token synthisized in your grammar.
MATCH is a list of elements that are to be matched if RESULT is to be
made.  The optional lambda expression is a list containing simplified
rules for concocting the parse tree.

   In bison, each time an element of a MATCH is found, it is "shifted"
onto the parser stack.  (The stack of matched elements.)  When all of
MATCH1's elements have been matched, it is "reduced" to RESULT.  *Note
(bison)Algorithm::.

   The first RESULT written into your language specification should be
`bovine-toplevel', or the symbol specified with `%start'.  When
starting a parse for a file, this is the default token iterated over.
You can use any token you want in place of `bovine-toplevel' if you
specify what that nonterminal will be with a `%start' token in the
settings section.

   MATCH is made up of symbols and strings.  A symbol such as `foo'
means that a syntactic token of type `foo' must be matched.  A string
in the mix means that the previous symbol must have the additional
constraint of exactly matching it.  Thus, the combination:

     symbol "moose"

   means that a symbol must first be encountered, and then it must
`string-match "moose"'.  Be especially careful to remember that the
string is a regular expression.  The code:

     punctuation "."

   will match any punctuation.

   For the above example in bison, a LEX rule would be used to create a
new token MOOSE.  In this case, the MOOSE token would appear.  For the
bovinator, this task was mixed into the language definition to simplify
implementation, though Bison's technique is more efficient.

   To make a symbol match explicity for keywords, for example, you can
use the `%token' command in the settings section to create new symbols.

     %token MOOSE "moose"
     
     find_a_moose: MOOSE
                 ;

   will match "moose" explicitly, unlike the previous example where
moose need only appear in the symbol.  This is because "moose" will be
converted to MOOSE in the lexical analysis stage.  Thus the symbol
MOOSE won't be available any other way.

   If we specify our token in this way:

     %token MOOSE symbol "moose"
     
     find_a_moose: MOOSE
                 ;

   then `MOOSE' will match the string "moose" explicitly, but it won't
do so at the lexical level, allowing use of the text "moose" in other
forms of regular expressions.

   Non symbol tokens are also alowed.  For example:

     %token PERIOD punctuation "."
     
     filename : symbol PERIOD symbol
              ;

   will explicitly match one period when used in the above rule.


File: semantic.info,  Node: Optional Lambda Expression,  Next: Examples,  Prev: Rules,  Up: BNF conversion

Optional Lambda Expressions
===========================

   The OLE (Optional Lambda Expression) is converted into a bovine
lambda *Note Bovinating::. This lambda has special short-cuts to
simplify reading the emacs bnf definition.  An OLE like this:

     ( $1 )

   results in a lambda return which consists entirely of the string or
object found by matching the first (zeroeth) element of match.  An OLE
like this:

     ( ,(foo $1) )

   executes `foo' on the first argument, and then splices it's return
into the return list whereas:

     ( (foo $1) )

   executes foo, and that is placed in the return list.

   Here are other things that can appear inline:
`$1'
     the first object matched.

`,$1'
     the first object spliced into the list (assuming it is a list from
     a non-terminal)

`'$1'
     the first object matched, placed in a list.  ie ( $1 )

`foo'
     the symbol foo (exactly as displayed)

`(foo)'
     a function call to foo which is stuck into the return list.

`,(foo)'
     a function call to foo which is spliced into the return list.

`'(foo)'
     a function call to foo which is stuck into the return list in a
     list.

`(EXPAND $1 nonterminal depth)'
     a list starting with EXPAND performs a recursive parse on the token
     passed to it (represented by $1 above.)  The semantic list is a
     common token to expand, as there are often interesting things in
     the list.  The NONTERMINAL is a symbol in your table which the
     bovinator will start with when parsing.  NONTERMINAL's definition
     is the same as any other nonterminal.  DEPTH should be at least 1
     when descending into a semantic list.

`(EXPANDFULL $1 nonterminal depth)'
     is like EXPAND, except that the parser will iterate over
     NONTERMINAL until there are no more matches.  (The same way the
     parser iterates over `bovine-toplevel'. This lets you have much
     simpler rules in this specific case, and also lets you have
     positional information in the returned tokens, and error skipping.

`(ASSOC symbol1 value1 symbol2 value2 ... )'
     This is used for creating an association list.  Each SYMBOL is
     included in the list if the associated VALUE is non-nil.  While
     the items are all listed explicitly, the created structure is an
     association list of the form:
          ( ( symbol1 . value1) (symbol2 . value2) ... )

   If the symbol `%quotemode backquote' is specified, then use `,@' to
splice a list in, and `,' to evaluate the expression.  This lets you
send `$1' as a symbol into a list instead of having it expanded inline.


File: semantic.info,  Node: Examples,  Prev: Optional Lambda Expression,  Up: BNF conversion

Examples
========

   The rule:

     SYMBOL : symbol

   is equivalent to

     SYMBOL : symbol
              ( $1 )

   which, if it matched the string "A", would return

     ( "A" )

   If this rule were used like this:

     ASSIGN: SYMBOL punctuation "=" SYMBOL
             ( $1 $# )

   it would match "A=B", and return

     ( ("A") ("B") )

   The letters A and B come back in lists because SYMBOL is a
nonterminal, not an actual lexical element.

   to get a better result with nonterminals, use , to splice lists in
like this;

     ASSIGN: SYMBOL punctuation "=" SYMBOL
             ( ,$1 ,$3 )

   which would return

     ( "A" "B" )


File: semantic.info,  Node: Compiling,  Next: Debugging,  Prev: BNF conversion,  Up: Top

Compiling a language file with the bovinator
********************************************

   From a program you can use the function `semantic-bovinate-toplevel'.
This function takes one optional parameter specifying if the cache
should be refreshed.  By default, the cached results of the last parse
are always used.  Specifying that the cache should be checked will cause
it to be flushed if it is out of date.

   Another function you can use is `semantic-bovinate-nonterminal'.
This command takes a token stream returned by the function
`semantic-flex' followed by a DEPTH (as above).  This takes an
additional optional argument of NONTERMINAL which is the nonterminal in
your table it is to start parsing with.

 - Command: bovinate &optional clear
     Bovinate the current buffer.  Show output in a temp buffer.
     Optional argument CLEAR will clear the cache before bovinating.

 - Command: semantic-clear-toplevel-cache
     Clear the toplevel bovin cache for the current buffer.  Clearing
     the cache will force a complete reparse next time a token stream
     is requested.

 - Function: semantic-bovinate-toplevel &optional checkcache
     Bovinate the entire current buffer.  If the optional argument
     CHECKCACHE is non-`nil', then flush the cache iff there has been a
     size change.


File: semantic.info,  Node: Debugging,  Next: Utilities,  Prev: Compiling,  Up: Top

Debugging
*********

   Writing language files using BNF is significantly easier than writing
then using regular expressions in a functional manner.  Debugging them,
however, can still prove challenging.

   There are two ways to debug a language definition if it is not
behaving as expected.  One way is to debug against the source `.bnf'
file.  The second is to debug against the lisp table created from the
`.bnf' source, or perhaps written by hand.

   If your language definition was written in BNF notation, debugging is
quite easy.  The command `bovinate-debug' will start you off.

 - Command: bovinate-debug
     Bovinate the current buffer and run in debug mode.

   If you prefer debugging against the Lisp table, find the table in a
buffer, place the cursor in it, and use the command
`semantic-bovinate-debug-set-table' in it.

 - Command: semantic-bovinate-debug-set-table
     Set the table for the next debug to be here.

   After the table is set, the `bovinate-debug' command can be run at
any time for the given language.

   While debugging, two windows are visible.  One window shows the file
being parse, and the syntactic token being tested is highlighted.  The
second window shows the table being used (either in the BNF source, or
the Lisp table.) with the current rule highlighted.  The cursor will
sit on the specific match rule being tested against.

   In the minibuffer, a brief summary of the current situation is
listed.  The first element is the syntactic token which is a list of
the form:

     (TYPE START . END)

   The rest of the display is a list of all strings collected for the
currently tested rule.  Each time a new rule is entered, the list is
restarted.  Upon returning from a rule into a previous match list, the
previous match list is restored, with the production of the dependent
rule in the list.

   Use `C-g' to stop debugging.  There are no commands for any fancier
types of debugging.


File: semantic.info,  Node: Utilities,  Next: Current Context,  Prev: Debugging,  Up: Top

Utilities
*********

   Once a source file has been parsed, the follwing APIs can be used to
write programs that use the token stream most effectivly.

* Menu:

* Token Queries::               Getting info about a parsed token (nonterminal).
* Nonterminal Streams::         Working with streams of nonterminals
* Nonterminal Completion::      Completing read functions.
* Override Methods::            Language dependent functions.
* Parser Hooks::                How to know when tags change.


File: semantic.info,  Node: Token Queries,  Next: Nonterminal Streams,  Prev: Utilities,  Up: Utilities

Token Queries
=============

   When writing programs that use the bovinator, the following functions
are needed to find get details out of a nonterminal.

 - Function: semantic-token-token token
     Retrieve from TOKEN the token identifier.  ie, the symbol
     `'variable', `'function', `'type', or other.

 - Function: semantic-token-name token
     Retrieve the name of TOKEN.

 - Function: semantic-token-docstring token &optional buffer
     Retrieve the documentation of TOKEN.  Optional argument BUFFER
     indicates where to get the text from.  If not provided, then only
     the POSITION can be provided.

 - Function: semantic-token-overlay token
     Retrieve the OVERLAY part of TOKEN.  The returned item may be an
     overlay or an unloaded buffer representation.

 - Function: semantic-token-extent token
     Retrieve the extent (START END) of TOKEN.

 - Function: semantic-token-start token
     Retrieve the start location of TOKEN.

 - Function: semantic-token-end token
     Retrieve the end location of TOKEN.

 - Function: semantic-token-type token
     Retrieve the type of TOKEN.

 - Function: semantic-token-put token property value
     On TOKEN, set PROPERTY to VALUE.

 - Function: semantic-token-get token property
     For TOKEN get the value of PROPERTY.

 - Function: semantic-token-extra-spec token spec
     Retrieve a specifier for the variable TOKEN.  SPC is the symbol
     whose modifier value to get.  This function can get specifiers
     from any type of TOKEN.  Do not use this function if you know what
     type of token you are dereferencing.  Instead, use the function
     specific to that token type.  It will be faster.

 - Function: semantic-token-type-parts token
     Retrieve the parts of the type TOKEN.

 - Function: semantic-token-type-parent token
     Retrieve the parent of the type TOKEN.  The return value is a
     list.  A value of `nil' means no parents.  The "car" of the list
     is either the parent class, or a list of parent classes.  The
     "cdr" of the list is the list of interfaces, or abstract classes
     which are parents of TOKEN.

 - Function: semantic-token-type-parent-superclass token
     Retrieve the parent superclasses of type type TOKEN.

 - Function: semantic-token-type-parent-implement token
     Retrieve the parent interfaces of type type TOKEN.

 - Function: semantic-token-type-modifiers token
     Retrieve the type modifiers for the type TOKEN.

 - Function: semantic-token-type-extra-specs token
     Retrieve the extra specifiers for the type TOKEN.

 - Function: semantic-token-type-extra-spec token spec
     Retrieve a extra specifier for the type TOKEN.  SPEC is the symbol
     whose modifier value to get.

 - Function: semantic-token-function-args token
     Retrieve the arguments of the function TOKEN.

 - Function: semantic-token-function-modifiers token
     Retrieve the type modifiers of the function TOKEN.

 - Function: semantic-token-function-destructor token
     Non-`nil' if TOKEN is a destructor function.

 - Function: semantic-token-function-extra-specs token
     Retrieve the extra specifiers of the function TOKEN.

 - Function: semantic-token-function-extra-spec token spec
     Retrieve a specifier for the function TOKEN.  SPEC is a symbol
     whose specifier value to get.

 - Function: semantic-token-function-throws token
     Retrieve the throws signal of the function TOKEN.  This is an
     optional field, and returns `nil' if it doesn't exist.

 - Function: semantic-token-function-parent token
     The parent of the function TOKEN.  A function has a parent if it
     is a method of a class, and if the function does not appear in
     body of it's parent class.

 - Function: semantic-token-variable-const token
     Retrieve the status of constantness from the variable TOKEN.

 - Function: semantic-token-variable-default token
     Retrieve the default value of the variable TOKEN.

 - Function: semantic-token-variable-modifiers token
     Retrieve type modifiers for the variable TOKEN.

 - Function: semantic-token-variable-extra-specs token
     Retrieve extra specifiers for the variable TOKEN.

 - Function: semantic-token-variable-extra-spec token spec
     Retrieve a specifier value for the variable TOKEN.  SPEC is the
     symbol whose specifier value to get.

 - Function: semantic-token-include-system token
     Retrieve the flag indicating if the include TOKEN is a sysmtem
     include.

   For override methods that query a token, see *Note Token Details::.


File: semantic.info,  Node: Nonterminal Streams,  Next: Nonterminal Completion,  Prev: Token Queries,  Up: Utilities

Nonterminal streams
===================

   These functions take some key, and returns information found inside
the nonterminal stream returned by the bovinator.  Some will return one
token (the first matching item found.)  Others will return a list of all
items matching a given criterion.

   These functions query the current buffer's overlay system for tokens.

 - Function: semantic-find-nonterminal-by-overlay &optional
          positionormarker buffer
     Find all nonterminals covering POSITIONORMARKER by using overlays.
     If POSITIONORMARKER is `nil', use the current point.  Optional
     BUFFER is used if POSITIONORMARKER is a number, otherwise the
     current buffer is used.  This finds all tokens covering the
     specified position by checking for all overlays covering the
     current spot.  They are then sorted from largest to smallest via
     the start location.

 - Function: semantic-find-nonterminal-by-overlay-in-region start end
          &optional buffer
     Find all nonterminals which exist in whole or in part between
     START and END.  Uses overlays to determine positin.  Optional
     BUFFER argument specifies the buffer to use.

 - Function: semantic-current-nonterminal
     Return the current nonterminal in the current buffer.  If there
     are more than one in the same location, return the smallest token.

 - Function: semantic-current-nonterminal-parent
     Return the current nonterminals parent in the current buffer.  A
     token's parent would be a containing structure, such as a type
     containing a field.  Return `nil' if there is no parent.

   These functions search the entire stream for tokens matches a
specific criteria.

 - Function: semantic-find-nonterminal-by-name name streamorbuffer
          &optional search-parts search-include
     Find a nonterminal NAME within STREAMORBUFFER.  NAME is a string.
     If SEARCH-PARTS is non-`nil', search children of tokens.  If
     SEARCH-INCLUDE is non-`nil', search include files.

 - Function: semantic-find-nonterminal-by-property property value
          streamorbuffer &optional search-parts search-includes
     Find all nonterminals with PROPERTY equal to VALUE in
     STREAMORBUFFER.  Properties can be added with "semantic-token-put".
     Optional argument SEARCH-PARTS and SEARCH-INCLUDES are passed to
     "semantic-find-nonterminal-by-function".

 - Function: semantic-find-nonterminal-by-extra-spec spec
          streamorbuffer &optional search-parts search-includes
     Find all nonterminals with a given SPEC in STREAMORBUFFER.  SPEC
     is a symbol key into the modifiers association list.  Optional
     argument SEARCH-PARTS and SEARCH-INCLUDES are passed to
     "semantic-find-nonterminal-by-function".

 - Function: semantic-find-nonterminal-by-extra-spec-value spec value
          streamorbuffer &optional search-parts search-includes
     Find all nonterminals with a given SPEC equal to VALUE in
     STREAMORBUFFER.  SPEC is a symbol key into the modifiers
     association list.  VALUE is the value that SPEC should match.
     Optional argument SEARCH-PARTS and SEARCH-INCLUDES are passed to
     "semantic-find-nonterminal-by-function".

 - Function: semantic-find-nonterminal-by-position position
          streamorbuffer &optional nomedian
     Find a nonterminal covering POSITION within STREAMORBUFFER.
     POSITION is a number, or marker.  If NOMEDIAN is non-`nil', don't
     do the median calculation, and return nil.

 - Function: semantic-find-innermost-nonterminal-by-position position
          streamorbuffer &optional nomedian
     Find a list of nonterminals covering POSITION within
     STREAMORBUFFER.  POSITION is a number, or marker.  If NOMEDIAN is
     non-`nil', don't do the median calculation, and return nil.  This
     function will find the topmost item, and recurse until no more
     details are available of findable.

 - Function: semantic-find-nonterminal-by-token token streamorbuffer
          &optional search-parts search-includes
     Find all nonterminals with a token TOKEN within STREAMORBUFFER.
     TOKEN is a symbol representing the type of the tokens to find.
     Optional argument SEARCH-PARTS and SEARCH-INCLUDE are passed to
     "semantic-find-nonterminal-by-function".

 - Function: semantic-find-nonterminal-standard streamorbuffer
          &optional search-parts search-includes
     Find all nonterminals in STREAMORBUFFER which define simple token
     types.  Optional argument SEARCH-PARTS and SEARCH-INCLUDE are
     passed to "semantic-find-nonterminal-by-function".

 - Function: semantic-find-nonterminal-by-type type streamorbuffer
          &optional search-parts search-includes
     Find all nonterminals with type TYPE within STREAMORBUFFER.  TYPE
     is a string which is the name of the type of the token returned.
     Optional argument SEARCH-PARTS and SEARCH-INCLUDES are passed to
     "semantic-find-nonterminal-by-function".

 - Function: semantic-find-nonterminal-by-function function
          streamorbuffer &optional search-parts search-includes
     Find all nonterminals in which FUNCTION match within
     STREAMORBUFFER.  FUNCTION must return non-`nil' if an element of
     STREAM will be included in the new list.

     If optional argument SEARCH-PARTS is non-`nil', all sub-parts of
     tokens are searched.  The overloadable function
     "semantic-nonterminal-children" is used for the searching child
     lists.  If SEARCH-PARTS is the symbol `'positiononly', then only
     children that have positional information are searched.

     If SEARCH-INCLUDES is non-`nil', then all include files are also
     searched for matches.

 - Function: semantic-find-nonterminal-by-function-first-match function
          streamorbuffer &optional search-parts search-includes
     Find the first nonterminal which FUNCTION match within
     STREAMORBUFFER.  FUNCTION must return non-`nil' if an element of
     STREAM will be included in the new list.  If optional argument
     SEARCH-PARTS, all sub-parts of tokens are searched.  The
     overloadable function "semantic-nonterminal-children" is used for
     searching.  If SEARCH-INCLUDES is non-`nil', then all include
     files are also searched for matches.

 - Function: semantic-recursive-find-nonterminal-by-name name buffer
     Recursivly find the first occurance of NAME.  Start search with
     BUFFER.  Recurse through all dependencies till found.  The return
     item is of the form (BUFFER TOKEN) where BUFFER is the buffer in
     which TOKEN (the token found to match NAME) was found.


File: semantic.info,  Node: Nonterminal Completion,  Next: Override Methods,  Prev: Nonterminal Streams,  Up: Utilities

Nonterminal completion
======================

   These functions provide ways reading the names of items in a buffer
with completion.

 - Function: semantic-read-symbol prompt &optional default stream filter
     Read a symbol name from the user for the current buffer.  PROMPT
     is the prompt to use.  Optional arguments: DEFAULT is the default
     choice.  If no default is given, one is read from under point.
     STREAM is the list of tokens to complete from.  FILTER is provides
     a filter on the types of things to complete.  FILTER must be a
     function to call on each element.  (See

 - Function: semantic-read-variable prompt &optional default stream
     Read a variable name from the user for the current buffer.  PROMPT
     is the prompt to use.  Optional arguments: DEFAULT is the default
     choice.  If no default is given, one is read from under point.
     STREAM is the list of tokens to complete from.

 - Function: semantic-read-function prompt &optional default stream
     Read a function name from the user for the current buffer.  PROMPT
     is the prompt to use.  Optional arguments: DEFAULT is the default
     choice.  If no default is given, one is read from under point.
     STREAM is the list of tokens to complete from.

 - Function: semantic-read-type prompt &optional default stream
     Read a type name from the user for the current buffer.  PROMPT is
     the prompt to use.  Optional arguments: DEFAULT is the default
     choice.  If no default is given, one is read from under point.
     STREAM is the list of tokens to complete from.


File: semantic.info,  Node: Override Methods,  Next: Parser Hooks,  Prev: Nonterminal Completion,  Up: Utilities

Override Methods
================

   These functions are called `override methods' because they provide
generic behaviors, which a given language can override.  For example,
finding a dependency file in Emacs lisp can be done with the
`locate-library' command (which overrides the default behavior.)  In C,
a dependency can be found by searching a generic search path which can
be passed in via a variable.

* Menu:

* Token->Text:: Converting Tokens into text strings
* Token Details:: Arbitrary token detail fetching
* Local Context:: Deriving information about a language specific local
                  context.
* Making New Methods:: How to add your own methods for a tool


File: semantic.info,  Node: Token->Text,  Next: Token Details,  Prev: Override Methods,  Up: Override Methods

Token->Text
-----------

   Any given token consists of Meta information which is best viewed in
some textual form.  This could be as simple as the token's name, or as
a prototype to be added to header file in C.  Not only are there
several default converters from a Token into text, but there is also
some convenient variables that can be used with them.  Use these
variables to allow options on output forms when displaying tokens in
your programs.

 - Variable: semantic-token->text-functions
     List of functions which convert a token to text.  Each function
     must take the parameters TOKEN &optional PARENT COLOR.  TOKEN is
     the token to convert.  PARENT is a parent token or name which
     refers to the structure or class which contains TOKEN.  PARENT is
     NOT a class which a TOKEN would claim as a parent.  COLOR
     indicates that the generated text should be colored using
     `font-lock'.

 - Variable: semantic-token->text-custom-list
     A List used by customizeable variables to choose a token to text
     function.  Use this variable in the `:type' field of a
     customizable variable.

   Every token to text conversion function must take the same
parameters, which are TOKEN, the token to be converted, PARENT, the
containing parent (like a structure which contains a variable), and
COLOR, which is a flag specifying that color should be applied to the
returned string.

   When creating, or using these strings, particularly with color, use
"concat" to build up larger strings instead of "format".  This will
preserve text properties.

 - Function: semantic-name-nonterminal token &optional parent color
     Return the name string describing TOKEN.  The name is the shortest
     possible representation.  Optional argument PARENT is the parent
     type if TOKEN is a detail.  Optional argument COLOR means
     highlight the prototype with font-lock colors.

 - Function: semantic-summarize-nonterminal token &optional parent color
     Summarize TOKEN in a reasonable way.  Optional argument PARENT is
     the parent type if TOKEN is a detail.  Optional argument COLOR
     means highlight the prototype with font-lock colors.

 - Function: semantic-prototype-nonterminal token &optional parent color
     Return a prototype for TOKEN.  This function should be overloaded,
     though it need not be used.  This is because it can be used to
     create code by language independent tools.  Optional argument
     PARENT is the parent type if TOKEN is a detail.  Optional argument
     COLOR means highlight the prototype with font-lock colors.

 - Function: semantic-prototype-file buffer
     Return a file in which prototypes belonging to BUFFER should be
     placed.  Default behavior (if not overriden) looks for a token
     specifying the prototype file, or the existence of an EDE variable
     indicating which file prototypes belong in.

 - Function: semantic-abbreviate-nonterminal token &optional parent
          color
     Return an abbreviated string describing TOKEN.  The abbreviation
     is to be short, with possible symbols indicating the type of
     token, or other information.  Optional argument PARENT is the
     parent type if TOKEN is a detail.  Optional argument COLOR means
     highlight the prototype with font-lock colors.

 - Function: semantic-concise-prototype-nonterminal token &optional
          parent color
     Return a concise prototype for TOKEN.  Optional argument PARENT is
     the parent type if TOKEN is a detail.  Optional argument COLOR
     means highlight the prototype with font-lock colors.

 - Function: semantic-uml-abbreviate-nonterminal token &optional parent
          color
     Return a UML style abbreviation for TOKEN.  Optional argument
     PARENT is the parent type if TOKEN is a detail.  Optional argument
     COLOR means highlight the prototype with font-lock colors.


This is eshell.info, produced by makeinfo version 4.0 from eshell.texi.

   This is the first edition of the `Eshell Manual'.

INFO-DIR-SECTION Packages
START-INFO-DIR-ENTRY
* Eshell: (eshell.info).	An Emacs command shell.
END-INFO-DIR-ENTRY

   This document describes how to use and program the Emacs Command
Shell, or "Eshell".  No guarantee is made as the usability of this
software.  Use it at your own risk.  Neither is this documentation
guaranteed to be accurate or sufficient.

   Copyright (C) 1999, 2000 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under the
terms of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the Free Software Foundation instead of in the
original English.


File: eshell.info,  Node: Top,  Next: The Emacs shell,  Prev: (dir),  Up: (dir)

The Emacs Shell: Eshell
***********************

   Eshell is a command shell implemented entirely in Emacs Lisp.  It
invokes no external processes beyond those requested by the user.  It
is intended to be a functional replacement for command shells such as
bash, zsh, rc, 4dos; since Emacs itself is capable of handling most of
the tasks accomplished by such tools.

* Menu:

* The Emacs shell::                 eshell.

Core Functionality
* Argument parsing::                eshell-arg.
* Command invocation::              eshell-cmd.
* External commands::               eshell-ext.
* I/O management::                  eshell-io.
* User interface::                  eshell-mode.
* Extension modules::               eshell-module.
* Command options processing::      eshell-opt.
* Process management::              eshell-proc.
* Eshell test suite::               eshell-test.
* General utilities::               eshell-util.
* Variable handling::               eshell-var.

Optional Functionality
* Command aliases::                 eshell-alias.
* Login banner::                    eshell-banner.
* Basic shell commands::            eshell-basic.
* Argument completion::             eshell-cmpl.
* Directory navigation::            eshell-dirs.
* Extended filename globbing::      eshell-glob.
* History list management::         eshell-hist.
* Implementation of `ls' in Lisp::  eshell-ls.
* Value modifiers and predicates::  eshell-pred.
* Command prompts::                 eshell-prompt.
* Rebind keys at input::            eshell-rebind.
* Running script files.::           eshell-script.
* Smart display of output::         eshell-smart.
* Running visual commands::         eshell-term.
* UNIX commands in Lisp::           eshell-unix.
* Extra alias functions::           eshell-xtra.


File: eshell.info,  Node: The Emacs shell,  Next: Argument parsing,  Prev: Top,  Up: Top

The Emacs shell
***************

* Menu:

* What does Eshell offer you?::
* Eshell is free software::
* How to begin::
* Philosophy::
* Influences::
* User Options::
* Running Eshell::
* Reporting bugs::


File: eshell.info,  Node: What does Eshell offer you?,  Next: Eshell is free software,  Prev: The Emacs shell,  Up: The Emacs shell

What does Eshell offer you?
===========================

   Despite the sheer fact that running an Emacs shell can be fun, here
are a few of the unique features offered by Eshell:

   * Integration with the Emacs Lisp programming environment

   * A high degree of configurability

   * The ability to have the same shell on every system Emacs has been
     ported to. Since Eshell imposes no external requirements, and
     relies upon only the Lisp functions exposed by Emacs, it is quite
     operating system independent. Several of the common UNIX commands,
     such as ls, mv, rm, ln, etc., have been implemented in Lisp in
     order to provide a more consistent work environment.

   For those who might be using an older version of Eshell, version 2.1
represents an entirely new, module-based architecture. It supports most
of the features offered by modern shells. Here is a brief list of some
of its more visible features:

   * Command argument completion (tcsh, zsh)

   * Input history management (bash)

   * Intelligent output scrolling

   * Psuedo-devices (such as "/dev/clip" for copying to the clipboard)

   * Extended globbing (zsh)

   * Argument and globbing predication (zsh)

   * I/O redirection to buffers, files, symbols, processes, etc.

   * Many niceties otherwise seen only in 4DOS

   * Alias functions, both Lisp and Eshell-syntax

   * Piping, sequenced commands, background jobs, etc...


File: eshell.info,  Node: Eshell is free software,  Next: How to begin,  Prev: What does Eshell offer you?,  Up: The Emacs shell

Eshell is free software
=======================

   Eshell is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

   This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

   You should have received a copy of the GNU General Public License
along with Eshell; see the file COPYING.  If not, write to the Free
Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.


File: eshell.info,  Node: How to begin,  Next: Philosophy,  Prev: Eshell is free software,  Up: The Emacs shell

How to begin
============

   To start using Eshell, add the following to your .emacs file:

     (load "eshell-auto")

   This will define all of the necessary autoloads.

   Now type `M-x eshell'.  See the INSTALL file for full installation
instructions.


File: eshell.info,  Node: Philosophy,  Next: Influences,  Prev: How to begin,  Up: The Emacs shell

Philosophy
==========

   A shell is a layer which metaphorically surrounds the kernel, or
heart of an operating system.  This kernel can be seen as an engine of
pure functionality, waiting to serve, while the user programs take
advantage of that functionality to accomplish their purpose.

   The shell's role is to make that functionality accessible to the
user in an unformed state.  Very roughly, it associates kernel
functionality with textual commands, allowing the user to interact with
the operating system via linguistic constructs.  Process invocation is
perhaps the most significant form this takes, using the kernel's `fork'
and `exec' functions.

   Other programs also interact with the functionality of the kernel,
but these user applications typically offer a specific range of
functionality, and thus are not classed as "shells" proper.  (What they
lose in quiddity, they gain in rigidity).

   Emacs is also a user application, but it does make the functionality
of the kernel accessible through an interpreted language--namely, Lisp.
For that reason, there is little preventing Emacs from serving the
same role as a modern shell.  It too can manipulate the kernel in an
unpredetermined way to cause system changes.  All it's missing is the
shell-ish linguistic model.

   Enter Eshell.  Eshell translates "shell-like" syntax into Lisp in
order to exercise the kernel in the same manner as typical system
shells.  There is a fundamental difference here, however, although it
may seem subtle at first....

   Shells like csh and Bourne shell were written several decades ago,
in different times, under more restrictive circumstances.  This
confined perspective shows itself in the paradigm used by nearly all
command-line shells since.  They are linear in conception, byte
stream-based, sequential, and confined to movement within a single host
machine.

   Emacs, on the other hand, is more than just a limited translator
that can invoke subprocesses and redirect file handles.  It also
manages character buffers, windowing frames, network connections,
registers, bookmarks, processes, etc.  In other words, it's a very
multi-dimensional environment, within which eshell emulates a highly
linear methodology.

   Taking a moment, let's look at how this could affect the future of a
shell allowed to develop in such a wider field of play:

   * There is no reason why directory movement should be linear, and
     confined to a single file-system.  Emacs, through w3 and ange-ftp,
     has access to the entire Web.  Why not allow a user to cd to
     multiple directories simultaneously, for example?  It might make
     some tasks easier, such as diff'ing files separated by very long
     pathnames.

   * Data sources are available from anywhere Emacs can derive
     information from: not just from files or the output of other
     processes.

   * Multiple shell invocations all share the same environment--even
     the same process list!  It would be possible to have "process
     views", so that one buffer is watching standard output, another
     standard error, and another the result of standard output grep'd
     through a regular expression...

   * It is not necessary to "leave" the shell, losing all input and
     output history, environment variables, directory stack, etc.
     Emacs could save the contents of your eshell environment, and
     restore all of it (or at least as much as possible) each time you
     restart.  This could occur automatically, without requiring
     complex initialization scripts.

   * Typos occur all of the time; many of them are repeats of common
     errors, such as `dri' for `dir'.  Since executing non-existent
     programs is rarely the intention of the user, eshell could prompt
     for the replacement string, and then record that in a database of
     known misspellings. (Note: The typo at the beginning of this
     paragraph wasn't discovered until two months after I wrote the
     text; it was not intentional).

   * Emacs' register and bookmarking facilities can be used for
     remembering where you've been, and what you've seen--to varying
     levels of persistence.  They could perhaps even be tied to
     specific "moments" during eshell execution, which would include
     the environment at that time, as well as other variables.
     Although this would require functionality orthogonal to Emacs' own
     bookmarking facilities, the interface used could be made to
     operate very similarly.

   This presents a brief idea of what the fuller dimensionality of an
Emacs shell could offer.  It's not just the language of a shell that
determines how it's used, but also the Weltanschauung underlying its
design--and which is felt behind even the smallest feature.  I would
hope the freedom provided by using Emacs as a parent environment will
invite rich ideas from others.  It certainly feels as though all I've
done so far is to tie down the horse, so to speak, so that he will run
at a man's pace.


File: eshell.info,  Node: Influences,  Next: User Options,  Prev: Philosophy,  Up: The Emacs shell

Influences
==========

   The author of Eshell has been a long-time user of the following
shells, all of which contributed to Eshell's design:

   * rc

   * bash

   * zsh

   * sh

   * 4nt

   * csh


File: eshell.info,  Node: User Options,  Next: Running Eshell,  Prev: Influences,  Up: The Emacs shell

User Options
============

   The following user options modify the behavior of Eshell overall.

 - User Option: eshell-unload-hook
     A hook run when Eshell is unloaded from memory.

 - User Option: eshell-buffer-name
     The basename used for Eshell buffers.

 - User Option: eshell-directory-name
     The directory where Eshell control files should be kept.

 - User Option: eshell-prefer-to-shell
     If non-nil, \[shell-command] will use Eshell instead of shell-mode.


File: eshell.info,  Node: Running Eshell,  Next: Reporting bugs,  Prev: User Options,  Up: The Emacs shell

Running Eshell
==============

   There are only three commands used to invoke Eshell.  The first two
are intended for interactive use, while the third is meant for
programmers.  They are:

 - Command: eshell &optional ARG
     Create an interactive Eshell buffer.  The buffer used for Eshell
     sessions is determined by the value of `eshell-buffer-name'.  If
     there is already an Eshell session active in that buffer, Emacs
     will simply switch to it.  Otherwise, a new session will begin.  A
     new session is always created if the the prefix argument ARG is
     specified.  Returns the buffer selected (or created).

 - Command: eshell-command &optional COMMAND ARG
     Execute the Eshell command string COMMAND.  With prefix ARG,
     insert output into the current buffer at point.

 - Command: eshell-command-result COMMAND &optional STATUS-VAR
     Execute the given Eshell COMMAND, and return the result.  The
     result might be any Lisp object.  If STATUS-VAR is a symbol, it
     will be set to the exit status of the command.  This is the only
     way to determine whether the value returned corresponding to a
     successful execution.


File: eshell.info,  Node: Reporting bugs,  Prev: Running Eshell,  Up: The Emacs shell

Reporting bugs
==============

   Since Eshell has not yet been in use by a wide audience, and since
the number of possible configurations is quite large, it is certain
that many bugs slipped past the rigors of testing it was put through.
If you do encounter a bug, on any system, please report it--in addition
to any particular oddities in your configuration --so that the problem
may be corrected for the benefit of others.

 - Command: eshell-report-bug TOPIC
     Report a bug in Eshell.  Prompts for the TOPIC.  Leaves you in a
     mail buffer.  Please include any configuration details that might
     be involved.


File: eshell.info,  Node: Argument parsing,  Next: Command invocation,  Prev: The Emacs shell,  Up: Top

Argument parsing
****************

   Argument parsing involves transforming the arguments passed on the
command line into equivalent Lisp forms that, when evaluated, will
yield the values intended.

   Parsing of arguments can be extended by adding functions to the hook
`eshell-parse-argument-hook'.  For a good example of this, see
`eshell-parse-drive-letter', defined in eshell-dirs.el.

 - User Option: eshell-parse-argument-hook
     Define how to process Eshell command line arguments.  When each
     function on this hook is called, point will be at the current
     position within the argument list.  The function should either
     return nil, meaning that it did no argument parsing, or it should
     return the result of the parse as a sexp.  It is also responsible
     for moving the point forward to reflect the amount of input text
     that was parsed.

     If no function handles the current character at point, it will be
     treated as a literal character.


File: eshell.info,  Node: Command invocation,  Next: External commands,  Prev: Argument parsing,  Up: Top

Command invocation
******************

   Executing an Eshell command is as simple as typing it in and
pressing `RET'.  There are several different kinds of commands, however.

* Menu:

* Invoking external commands::
* Invoking Lisp functions::
* Alias functions::
* Lisp arguments::
* Command hooks::


File: eshell.info,  Node: Invoking external commands,  Next: Invoking Lisp functions,  Prev: Command invocation,  Up: Command invocation

Invoking external commands
==========================

   External commands cause processes to be created, by loading external
executables into memory.  This is what most normal shells do, most of
the time.  For more information, see *Note External commands::.


File: eshell.info,  Node: Invoking Lisp functions,  Next: Alias functions,  Prev: Invoking external commands,  Up: Command invocation

Invoking Lisp functions
=======================

   A Lisp function can be invoked using Lisp syntax, or command shell
syntax.  For example, to run `dired' to edit the current directory:

     /tmp $ (dired ".")

   Or:

     /tmp $ dired .

   The latter form is preferable, but the former is more precise, since
it involves no translations.  See *Note Argument parsing::, to learn
more about how arguments are transformed before passing them to
commands.

   Ordinarily, if `dired' were also available as an external command,
the external version would be called in preference to any Lisp function
of the same name.  To change this behavior so that Lisp functions
always take precedence, set `eshell-prefer-lisp-functions' to t.

 - User Option: eshell-prefer-lisp-functions
     If non-nil, prefer Lisp functions to external commands.


File: eshell.info,  Node: Alias functions,  Next: Lisp arguments,  Prev: Invoking Lisp functions,  Up: Command invocation

Alias functions
===============

   Whenever a command is specified using a simple name, such as `ls',
Eshell will first look for a Lisp function of the name `eshell/ls'.  If
it exists, it will be called in preference to any other command which
might have matched the name `ls' (such as command aliases, external
commands, Lisp functions of that name, etc).

   This is the most flexible mechanism for creating new commands, since
it does not pollute the global namespace, yet allows you to use all of
Lisp's facilities to define that piece of functionality.  Most of
Eshell's "builtin" commands are defined as alias functions.


File: eshell.info,  Node: Lisp arguments,  Next: Command hooks,  Prev: Alias functions,  Up: Command invocation

Lisp arguments
==============

   It is possible to invoke a Lisp form as an argument.  This can be
done either by specifying the form as you might in Lisp, or by using
the `$' character to introduce a value-interpolation:

     echo (+ 1 2)

   Or

     echo $(+ 1 2)

   The two forms are equivalent.  The second is required only if the
form being interpolated is within a string, or is a subexpression of a
larger argument:

     echo x$(+ 1 2) "String $(+ 1 2)"

   To pass a Lisp symbol as a argument, use the alternate quoting
syntax, since the single quote character is far too overused in shell
syntax:

     echo #'lisp-symbol

   Backquote can also be used:

     echo `(list ,lisp-symbol)

   Lisp arguments are identified using the following regexp:

 - User Option: eshell-lisp-regexp
     A regexp which, if matched at beginning of an argument, means Lisp.
     Such arguments will be passed to `read', and then evaluated.


File: eshell.info,  Node: Command hooks,  Prev: Lisp arguments,  Up: Command invocation

Command hooks
=============

   There are several hooks involved with command execution, which can
be used either to change or augment Eshell's behavior.

 - User Option: eshell-pre-command-hook
     A hook run before each interactive command is invoked.

 - User Option: eshell-post-command-hook
     A hook run after each interactive command is invoked.

 - User Option: eshell-prepare-command-hook
     A set of functions called to prepare a named command.  The command
     name and its argument are in `eshell-last-command-name' and
     `eshell-last-arguments'.  The functions on this hook can change
     the value of these symbols if necessary.

     To prevent a command from executing at all, set
     `eshell-last-command-name' to nil.

 - User Option: eshell-named-command-hook
     A set of functions called before a named command is invoked.  Each
     function will be passed the command name and arguments that were
     passed to `eshell-named-command'.

     If any of the functions returns a non-nil value, the named command
     will not be invoked, and that value will be returned from
     `eshell-named-command'.

     In order to substitute an alternate command form for execution, the
     hook function should throw it using the tag
     `eshell-replace-command'.  For example:

          (add-hook 'eshell-named-command-hook 'subst-with-cd)
          (defun subst-with-cd (command args)
            (throw 'eshell-replace-command
            (eshell-parse-command "cd" args)))

     Although useless, the above code will cause any non-glob, non-Lisp
     command (i.e., `ls' as opposed to `*ls' or `(ls)') to be replaced
     by a call to `cd' using the arguments that were passed to the
     function.

 - User Option: eshell-pre-rewrite-command-hook
     A hook run before command rewriting begins.  The terms of the
     command to be rewritten is passed as arguments, and may be
     modified in place.  Any return value is ignored.

 - User Option: eshell-rewrite-command-hook
     A set of functions used to rewrite the command argument.  Once
     parsing of a command line is completed, the next step is to
     rewrite the initial argument into something runnable.

     A module may wish to associate special behavior with certain
     argument syntaxes at the beginning of a command line.  They are
     welcome to do so by adding a function to this hook.  The first
     function to return a substitute command form is the one used.
     Each function is passed the command's full argument list, which is
     a list of sexps (typically forms or strings).

 - User Option: eshell-post-rewrite-command-hook
     A hook run after command rewriting is finished.  Each function is
     passed the symbol containing the rewritten command, which may be
     modified directly.  Any return value is ignored.


File: eshell.info,  Node: External commands,  Next: I/O management,  Prev: Command invocation,  Up: Top

External commands
*****************

   External commands are invoked when operating system executables are
loaded into memory, thus beginning a new process.

   To force a command to invoked external, either provide an explicit
pathname for the command argument, or prefix the command name with an
asterix character.  Example:

     grep        ; make invoke `grep' Lisp function, or `eshell/grep'
     /bin/grep   ; will definitely invoke /bin/grep
     *grep        ; will also invoke /bin/grep

 - User Option: eshell-binary-suffixes
     A list of suffixes used when searching for executable files.

 - User Option: eshell-force-execution
     If non-nil, try to execute binary files regardless of permissions.
     This can be useful on systems like Windows, where the operating
     system doesn't happen to honor the permission bits in certain
     cases; or in cases where you want to associate an interpreter with
     a particular kind of script file, but the language won't let you
     but a `#!' interpreter line in the file, and you don't want to
     make it executable since nothing else but Eshell will be able to
     understand `eshell-interpreter-alist'.

 - User Option: eshell-windows-shell-file
     The name of the shell command to use for DOS/Windows batch files.
     This defaults to nil on non-Windows systems, where this variable is
     wholly ignored.

 - User Option: eshell-interpreter-alist
     An alist defining interpreter substitutions.  Each member is a
     cons cell of the form:

          (MATCH . INTERPRETER)

     MATCH should be a regexp, which is matched against the command
     name, or a function.  If either returns a non-nil value, then
     INTERPRETER will be used for that command.

     If INTERPRETER is a string, it will be called as the command name,
     with the original command name passed as the first argument, with
     all subsequent arguments following.  If INTERPRETER is a function,
     it will be called with all of those arguments.  Note that
     interpreter functions should throw `eshell-replace-command' with
     the alternate command form, or they should return a value
     compatible with the possible return values of
     `eshell-external-command', which see.

 - User Option: eshell-alternate-command-hook
     A hook run whenever external command lookup fails.  If a functions
     wishes to provide an alternate command, they must throw it using
     the tag `eshell-replace-command'.  This is done because the
     substituted command need not be external at all, and therefore
     must be passed up to a higher level for re-evaluation.

     Or, if the function returns a filename, that filename will be
     invoked with the current command arguments rather than the command
     specified by the user on the command line.

 - User Option: eshell-command-interpreter-max-length
     The maximum length of any command interpreter string, plus args.


File: eshell.info,  Node: I/O management,  Next: User interface,  Prev: External commands,  Up: Top

I/O management
**************

   Eshell's I/O management code provides a scheme for treating many
different kinds of objects--symbols, files, buffers, etc.--as though
they were files.

   At the moment, only output redirection is supported in Eshell.  To
use input redirection, the following syntax will work, assuming that
the command after the pipe is always an external command:

     cat <file> | <command>

   Otherwise, output redirection and piping are provided in a manner
consistent with most shells.  Therefore, only unique features are
mentioned here.

* Menu:

* Insertion::
* Pseudo-devices::
* Multiple output targets::


File: eshell.info,  Node: Insertion,  Next: Pseudo-devices,  Prev: I/O management,  Up: I/O management

Insertion
=========

   To insert at the location of point in a buffer, use `>>>':

     echo alpha >>> #<buffer *scratch*>;


File: eshell.info,  Node: Pseudo-devices,  Next: Multiple output targets,  Prev: Insertion,  Up: I/O management

Pseudo-devices
==============

   A few pseudo-devices are provided, since Emacs cannot write directly
to a UNIX device file:

     echo alpha > /dev/null   ; the bit bucket
     echo alpha > /dev/kill   ; set the kill ring
     echo alpha >> /dev/clip  ; append to the clipboard


File: eshell.info,  Node: Multiple output targets,  Prev: Pseudo-devices,  Up: I/O management

Multiple output targets
=======================

   Eshell can write to multiple output targets, including pipes.
Example:

     (+ 1 2) > a > b > c   ; prints number to all three files
     (+ 1 2) > a | wc      ; prints to 'a', and pipes to 'wc'

 - User Option: eshell-number-of-handles
     The number of file handles that eshell supports.  Currently this
     is standard input, output and error.  But even all of these Emacs
     does not currently support with asynchronous processes (which is
     what eshell uses so that you can continue doing work in other
     buffers) .

 - User Option: eshell-output-handle
     The index of the standard output handle.

 - User Option: eshell-error-handle
     The index of the standard error handle.

 - User Option: eshell-buffer-shorthand
     If non-nil, a symbol name can be used for a buffer in redirection.
     If nil, redirecting to a buffer requires buffer name syntax.  If
     this variable is set, redirection directly to Lisp symbols will be
     impossible.

     Example:

          echo hello > '*scratch*  ; works if `eshell-buffer-shorthand' is t
          echo hello > #<buffer *scratch*>  ; always works

 - User Option: eshell-print-queue-size
     The size of the print queue, for doing buffered printing.  This is
     basically a speed enhancement, to avoid blocking the Lisp code
     from executing while Emacs is redisplaying.

 - User Option: eshell-virtual-targets
     Map virtual devices name to Emacs Lisp functions.  If the user
     specifies any of the filenames above as a redirection target, the
     function in the second element will be called.

     If the third element is non-nil, the redirection mode is passed as
     an argument (which is the symbol `overwrite', `append' or
     `insert'), and the function is expected to return another
     function--which is the output function.  Otherwise, the second
     element itself is the output function.

     The output function is then called repeatedly with a single
     strings, with represents success pieces of the output of the
     command, until nil is passed, meaning EOF.

     NOTE: /dev/null is handled specially as a virtual target, and
     should not be added to this variable.


File: eshell.info,  Node: User interface,  Next: Extension modules,  Prev: I/O management,  Up: Top

User interface
**************

   This module contains code for handling input from the user.

   Basically, Eshell is used just like shell mode (<M-x shell>).  The
keystrokes for navigating the buffer, and accessing the command
history, are identical.  Unlike shell mode, however, Eshell mode's
governing process is Emacs itself.  With shell mode, an inferior shell
process is executed that communicates with Emacs via comint --a mode
for handling sub-process interaction.  Eshell mode, on the other hand,
is a truly native Emacs shell.  No subprocess are invoked except the
ones requested by the user at the prompt.

   After entering a command, use `RET' to invoke it ([Command
invocation]) .  If there is a command on disk, it will be executed as
in a normal shell.  If there is no command by that name on disk, but a
Lisp function with that name is defined, the Lisp function will be
called, using the arguments passed on the command line.

   Some of the other features of the command interaction mode are:

   * `M-RET' can be used to accumulate further commands while a command
     is currently running.  Since all input is passed to the subprocess
     being executed, there is no automatic input queueing as there is
     with other shells.

   * `C-c C-t' can be used to truncate the buffer if it grows too large.

   * `C-c C-r' will move point to the beginning of the output of the
     last command.  With a prefix argument, it will narrow to view only
     that output.

   * `C-c C-o' will delete the output from the last command.

   * `C-c C-f' will move forward a complete shell argument.

   * `C-c C-b' will move backward a complete shell argument.

 - User Option: eshell-mode-unload-hook
     A hook that gets run when `eshell-mode' is unloaded.

 - User Option: eshell-mode-hook
     A hook that gets run when `eshell-mode' is entered.

 - User Option: eshell-first-time-mode-hook
     A hook that gets run the first time `eshell-mode' is entered.
     That is to say, the first time during an Emacs session.

 - User Option: eshell-exit-hook
     A hook that is run whenever `eshell' is exited.  This hook is only
     run if exiting actually kills the buffer.

 - User Option: eshell-kill-on-exit
     If non-nil, kill the Eshell buffer on the `exit' command.
     Otherwise, the buffer will simply be buried.

 - User Option: eshell-input-filter-functions
     Functions to call before input is processed.  The input is
     contained in the region from `eshell-last-input-start' to
     `eshell-last-input-end'.

 - User Option: eshell-expand-input-functions
     Functions to call before input is parsed.  Each function is passed
     two arguments, which bounds the region of the current input text.

 - User Option: eshell-scroll-to-bottom-on-input
     Controls whether input to interpreter causes window to scroll.  If
     nil, then do not scroll.  If t or `all', scroll all windows showing
     buffer.  If `this', scroll only the selected window.

     See `eshell-preinput-scroll-to-bottom'.

 - User Option: eshell-scroll-to-bottom-on-output
     Controls whether interpreter output causes window to scroll.  If
     nil, then do not scroll.  If t or `all', scroll all windows showing
     buffer.  If `this', scroll only the selected window.  If `others',
     scroll only those that are not the selected window.

     See variable `eshell-scroll-show-maximum-output' and function
     `eshell-postoutput-scroll-to-bottom'.

 - User Option: eshell-scroll-show-maximum-output
     Controls how interpreter output causes window to scroll.  If
     non-nil, then show the maximum output when the window is scrolled.

     See variable `eshell-scroll-to-bottom-on-output' and function
     `eshell-postoutput-scroll-to-bottom'.

 - User Option: eshell-buffer-maximum-lines
     The maximum size in lines for eshell buffers.  Eshell buffers are
     truncated from the top to be no greater than this number, if the
     function `eshell-truncate-buffer' is on
     `eshell-output-filter-functions'.

 - User Option: eshell-output-filter-functions
     Functions to call before output is displayed.  These functions are
     only called for output that is displayed interactively, and not
     for output which is redirected.

 - User Option: eshell-preoutput-filter-functions
     Functions to call before output is inserted into the buffer.
     These functions get one argument, a string containing the text to
     be inserted.  They return the string as it should be inserted.

 - User Option: eshell-password-prompt-regexp
     Regexp matching prompts for passwords in the inferior process.
     This is used by `eshell-watch-for-password-prompt'.

 - User Option: eshell-skip-prompt-function
     A function called from beginning of line to skip the prompt.

 - User Option: eshell-status-in-modeline
     If non-nil, let the user know a command is running in the modeline.

 - Command: eshell-mode
     Emacs shell interactive mode.



File: eshell.info,  Node: Extension modules,  Next: Command options processing,  Prev: User interface,  Up: Top

Extension modules
*****************

   The `eshell-module' group is for Eshell extension modules, which
provide optional behavior which the user can enable or disable by
customizing the variable `eshell-modules-list'.

 - User Option: eshell-module-unload-hook
     A hook run when `eshell-module' is unloaded.

 - User Option: eshell-modules-list
     A list of optional add-on modules to be loaded by Eshell.  Changes
     will only take effect in future Eshell buffers.


File: eshell.info,  Node: Command options processing,  Next: Process management,  Prev: Extension modules,  Up: Top

Command options processing
**************************

   The options processing code handles command argument parsing for
Eshell commands implemented in Lisp.

   User Functions:


File: eshell.info,  Node: Process management,  Next: Eshell test suite,  Prev: Command options processing,  Up: Top

Process management
******************

   When Eshell invokes external commands, it always does so
asynchronously, so that Emacs isn't tied up waiting for the process to
finish.

   User Variables:

 - User Option: eshell-process-wait-seconds
     The number of seconds to delay waiting for a synchronous process.

 - User Option: eshell-process-wait-milliseconds
     The number of milliseconds to delay waiting for a synchronous
     process.

 - User Option: eshell-done-messages-in-minibuffer
     If non-nil, subjob "Done" messages will display in minibuffer.

 - User Option: eshell-delete-exited-processes
     If nil, process entries will stick around until `jobs' is run.
     This variable sets the buffer-local value of
     `delete-exited-processes' in Eshell buffers.

     This variable causes Eshell to mimic the behavior of bash when set
     to nil.  It allows the user to view the exit status of a completed
     subjob (process) at their leisure, because the process entry
     remains in memory until the user examines it using
     \[list-processes].

     Otherwise, if `eshell-done-messages-in-minibuffer' is nil, and this
     variable is set to t, the only indication the user will have that a
     subjob is done is that it will no longer appear in the
     \[list-processes\] display.

     Note that Eshell will have to be restarted for a change in this
     variable's value to take effect.

 - User Option: eshell-reset-signals
     If a termination signal matches this regexp, the terminal will be
     reset.

 - User Option: eshell-exec-hook
     Called each time a process is exec'd by
     `eshell-gather-process-output'.  It is passed one argument, which
     is the process that was just started.  It is useful for things
     that must be done each time a process is executed in a eshell mode
     buffer (e.g., `process-kill-without-query').  In contrast,
     `eshell-mode-hook' is only executed once when the buffer is
     created.

 - User Option: eshell-kill-hook
     Called when a process run by `eshell-gather-process-output' has
     ended.  It is passed two arguments: the process that was just
     ended, and the termination status (as a string).  Note that the
     first argument may be nil, in which case the user attempted to
     send a signal, but there was no relevant process.  This can be
     used for displaying help information, for example.

 - User Option: eshell-kill-process-wait-time
     Seconds to wait between sending termination signals to a
     subprocess.

 - User Option: eshell-kill-process-signals
     Signals used to kill processes when an Eshell buffer exits.
     Eshell calls each of these signals in order when an Eshell buffer
     is killed; if the process is still alive afterwards, Eshell waits a
     number of seconds defined by `eshell-kill-process-wait-time', and
     tries the next signal in the list.

 - User Option: eshell-kill-processes-on-exit
     If non-nil, kill active processes when exiting an Eshell buffer.
     Emacs will only kill processes owned by that Eshell buffer.

     If nil, ownership of background and foreground processes reverts to
     Emacs itself, and will die only if the user exits Emacs, calls
     `kill-process', or terminates the processes externally.

     If `ask', Emacs prompts the user before killing any processes.

     If `every', it prompts once for every process.

     If t, it kills all buffer-owned processes without asking.

     Processes are first sent SIGHUP, then SIGINT, then SIGQUIT, then
     SIGKILL.  The variable `eshell-kill-process-wait-time' specifies
     how long to delay between signals.


File: eshell.info,  Node: Eshell test suite,  Next: General utilities,  Prev: Process management,  Up: Top

Eshell test suite
*****************

   This module is meant to ensure that Eshell is working correctly.

   The purpose of this module is to verify that Eshell works as
expected.  To run it on your system, use the command `M-x eshell-test'.


File: eshell.info,  Node: General utilities,  Next: Variable handling,  Prev: Eshell test suite,  Up: Top

General utilities
*****************

   This is general utility code, meant for use by Eshell itself.

 - User Option: eshell-group-file
     If non-nil, the name of the group file on your system.

 - User Option: eshell-passwd-file
     If non-nil, the name of the passwd file on your system.

 - User Option: eshell-hosts-file
     The name of the /etc/hosts file.

 - User Option: eshell-handle-errors
     If non-nil, Eshell will handle errors itself.  Setting this to nil
     is offered as an aid to debugging only.

 - User Option: eshell-private-file-modes
     The file-modes value to use for creating "private" files.

 - User Option: eshell-private-directory-modes
     The file-modes value to use for creating "private" directories.

 - User Option: eshell-tar-regexp
     Regular expression used to match tar file names.

 - User Option: eshell-convert-numeric-arguments
     If non-nil, converting arguments of numeric form to Lisp numbers.
     Numeric form is tested using the regular expression
     `eshell-number-regexp'.

 - User Option: eshell-number-regexp
     Regular expression used to match numeric arguments.  If
     `eshell-convert-numeric-arguments' is non-nil, and an argument
     matches this regexp, it will be converted to a Lisp number, using
     the function `string-to-number'.


File: eshell.info,  Node: Variable handling,  Next: Command aliases,  Prev: General utilities,  Up: Top

Variable handling
*****************

   Variable interpolation is introduced whenever the `$' character
appears unquoted in any argument (except when that argument is
surrounded by single quotes) .  It may be used to interpolate a
variable value, a subcommand, or even the result of a Lisp form.

   These are the possible variable interpolation syntaxes.  Also keep
in mind that if an argument looks like a number, it will be converted
to a number.  This is not significant when invoking external commands,
but it's important when calling Lisp functions.

     $VARIABLE

   Interval the value of an environment variable, or a Lisp variable

     $ALSO-VAR

   "-" is a legal part of a variable name.

     $<MYVAR>-TOO

   Only "MYVAR" is part of the variable name in this case.

     $#VARIABLE

   Returns the length of the value of VARIABLE.  This could also be
done using the `length' Lisp function.

     $(lisp)

   Returns result of lisp evaluation.  Note: Used alone like this, it
is identical to just saying (lisp); but with the variable expansion
form, the result may be interpolated a larger string, such as
`$(lisp)/other'.

     ${command}

   Returns the value of an eshell subcommand.  See the note above
regarding Lisp evaluations.

     $ANYVAR[10]

   Return the 10th element of ANYVAR.  If ANYVAR's value is a string,
it will be split in order to make it a list.  The splitting will occur
at whitespace.

     $ANYVAR[: 10]

   As above, except that splitting occurs at the colon now.

     $ANYVAR[: 10 20]

   As above, but instead of returning just a string, it now returns a
list of two strings.  If the result is being interpolated into a larger
string, this list will be flattened into one big string, with each
element separated by a space.

     $ANYVAR["\\\\" 10]

   Separate on backslash characters.  Actually, the first argument-- if
it doesn't have the form of a number, or a plain variable name --can be
any regular expression.  So to split on numbers, use `$ANYVAR["[0-9]+"
10 20]'.

     $ANYVAR[hello]

   Calls `assoc' on ANYVAR with `hello', expecting it to be an alist.

     $#ANYVAR[hello]

   Returns the length of the cdr of the element of ANYVAR who car is
equal to "hello".

   There are also a few special variables defined by Eshell.  `$$' is
the value of the last command (t or nil, in the case of an external
command).  This makes it possible to chain results:

     /tmp $ echo /var/spool/mail/johnw
     /var/spool/mail/johnw
     /tmp $ dirname $$
     /var/spool/mail/
     /tmp $ cd $$
     /var/spool/mail $

   `$_' refers to the last argument of the last command.  And $?
contains the exit code of the last command (0 or 1 for Lisp functions,
based on successful completion).

 - User Option: eshell-prefer-lisp-variables
     If non-nil, prefer Lisp variables to environment variables.

 - User Option: eshell-complete-export-definition
     If non-nil, completing names for `export' shows current definition.

 - User Option: eshell-variable-name-regexp
     A regexp identifying what constitutes a variable name reference.
     Note that this only applies for `$NAME'.  If the syntax `$<NAME>'
     is used, then NAME can contain any character, including angle
     brackets, if they are quoted with a backslash.

 - User Option: eshell-variable-aliases-list
     This list provides aliasing for variable references.  It is very
     similar in concept to what `eshell-user-aliases-list' does for
     commands.  Each member of this defines defines the name of a
     command, and the Lisp value to return for that variable if it is
     accessed via the syntax `$NAME'.

     If the value is a function, that function will be called with two
     arguments: the list of the indices that was used in the reference,
     and whether the user is requesting the length of the ultimate
     element.  For example, a reference of `$NAME[10][20]' would result
     in the function for alias `NAME' being called (assuming it were
     aliased to a function), and the arguments passed to this function
     would be the list `(10 20)', and nil.


File: eshell.info,  Node: Command aliases,  Next: Login banner,  Prev: Variable handling,  Up: Top

Command aliases
***************

   Command aliases allow for easy definition of alternate commands.

   Command aliases greatly simplify the definition of new commands.
They exist as an alternative to alias functions, which are otherwise
quite superior, being more flexible and natural to the Emacs Lisp
environment (if somewhat trickier to define; *Note Alias functions::).

* Menu:

* Creating aliases::
* Auto-correction of bad commands::


File: eshell.info,  Node: Creating aliases,  Next: Auto-correction of bad commands,  Prev: Command aliases,  Up: Command aliases

Creating aliases
================

   The user interface is simple: type `alias' followed by the command
name followed by the definition.  Argument references are made using
`$1', `$2', etc., or `$*'.  For example:

     alias ll 'ls -l $*'

   This will cause the command `ll NEWS' to be replaced by `ls -l
NEWS'.  This is then passed back to the command parser for reparsing.(1)

   To delete an alias, specify its name without a definition:

     alias ll

   Aliases are written to disk immediately after being defined or
deleted.  The filename in which they are kept is defined by the
following variable:

 - User Option: eshell-aliases-file
     The file in which aliases are kept.  Whenever an alias is defined
     by the user, using the `alias' command, it will be written to this
     file.  Thus, alias definitions (and deletions) are always
     permanent.  This approach was chosen for the sake of simplicity,
     since that's pretty much the only benefit to be gained by using
     this module.

   The format of this file is quite basic.  It specifies the alias
definitions in almost exactly the same way that the user entered them,
minus any argument quoting (since interpolation is not done when the
file is read).  Hence, it is possible to add new aliases to the alias
file directly, using a text editor rather than the `alias' command.
Or, this method can be used for editing aliases that have already
defined.

   Here is an example of a few different aliases, and they would appear
in the aliases file:

     alias clean rm -fr **/.#*~
     alias commit cvs commit -m changes $*
     alias ll ls -l $*
     alias info (info)
     alias reindex glimpseindex -o ~/Mail
     alias compact for i in ~/Mail/**/*~*.bz2(Lk+50) { bzip2 -9v $i }

   ---------- Footnotes ----------

   (1) Only the command text specified in the alias definition will be
reparsed.  Argument references (such as `$*') are handled using
variable values, which means that the expansion will not be reparsed,
but used directly.


File: eshell.info,  Node: Auto-correction of bad commands,  Prev: Creating aliases,  Up: Command aliases

Auto-correction of bad commands
===============================

   When a user enters the same unknown command many times during a
session, it is likely that they are experiencing a spelling difficulty
associated with a certain command.  To combat this, Eshell will offer
to automatically define an alias for that mispelled command, once a
given tolerance threshold has been reached.

 - User Option: eshell-bad-command-tolerance
     The number of failed commands to ignore before creating an alias.

   Whenever the same bad command name is encountered this many times,
the user will be prompted in the minibuffer to provide an alias name.
An alias definition will then be created which will result in an equal
call to the correct name.  In this way, Eshell gradually learns about
the commands that the user mistypes frequently, and will automatically
correct them!

   Note that a `$*' is automatically appended at the end of the alias
definition, so that entering it is unnecessary when specifying the
corrected command name.


File: eshell.info,  Node: Login banner,  Next: Basic shell commands,  Prev: Command aliases,  Up: Top

Login banner
************

   This sample module displays a welcome banner at login.  It exists so
that others wishing to create their own Eshell extension modules may
have a simple template to begin with.

   There is nothing to be done or configured in order to use this
module, other than to select it by customizing the variable
`eshell-modules-list'.  It will then display a version information
message whenever Eshell is loaded.

   This code is only an example of a how to write a well-formed
extension module for Eshell.  The better way to display login text is
to use the `eshell-script' module, and to echo the desired strings from
the user's `eshell-login-script' file.

   There is one configuration variable, which demonstrates how to
properly define a customization variable in an extension module.  In
this case, it allows the user to change the string which displays at
login time.

 - User Option: eshell-banner-message
     The banner message to be displayed when Eshell is loaded.  This
     can be any sexp, and should end with at least two newlines.


File: eshell.info,  Node: Basic shell commands,  Next: Argument completion,  Prev: Login banner,  Up: Top

Basic shell commands
********************

   The "basic" code provides a set of convenience functions which are
traditionally considered shell builtins.  Since all of the
functionality provided by them is accessible through Lisp, they are not
really builtins at all, but offer a command-oriented way to do the same
thing.

   There are very few basic Eshell commands--so-called builtins.  They
are: echo, umask, and version.

* Menu:

* `echo'::
* `umask'::
* `version'::


File: eshell.info,  Node: `echo',  Next: `umask',  Prev: Basic shell commands,  Up: Basic shell commands

`echo'
======

   The `echo' command repeats its arguments to the screen.  It is
optional whether this is done in a Lisp-friendly fashion (so that the
value of echo is useful to a Lisp command using the result of echo as
an argument), or whether it should try to act like a normal shell echo,
and always result in a flat string being returned.

 - User Option: eshell-plain-echo-behavior
     If non-nil, `echo' tries to behave like an ordinary shell echo.
     This comes at some detriment to Lisp functionality.  However, the
     Lisp equivalent of `echo' can always be achieved by using
     `identity'.

   An example of the difference is the following:

     echo Hello world

   If `eshell-plain-echo-behavior' is non-nil, this will yield the
string "Hello world".  If Lisp behavior is enabled, however, it will
yield a list whose two elements are the strings "Hello" and "world".
The way to write an equivalent expression for both would be:

     echo "Hello world"

   This always returns a single string.


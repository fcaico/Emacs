This is eshell.info, produced by makeinfo version 4.0 from eshell.texi.

   This is the first edition of the `Eshell Manual'.

INFO-DIR-SECTION Packages
START-INFO-DIR-ENTRY
* Eshell: (eshell.info).	An Emacs command shell.
END-INFO-DIR-ENTRY

   This document describes how to use and program the Emacs Command
Shell, or "Eshell".  No guarantee is made as the usability of this
software.  Use it at your own risk.  Neither is this documentation
guaranteed to be accurate or sufficient.

   Copyright (C) 1999, 2000 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under the
terms of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the Free Software Foundation instead of in the
original English.


File: eshell.info,  Node: `umask',  Next: `version',  Prev: `echo',  Up: Basic shell commands

`umask'
=======

   The umask command changes the default file permissions for newly
created files.  It uses the same syntax as bash.


File: eshell.info,  Node: `version',  Prev: `umask',  Up: Basic shell commands

`version'
=========

   This command reports the version number for Eshell and all its
dependent module, including the date when those modules were last
modified.


File: eshell.info,  Node: Argument completion,  Next: Directory navigation,  Prev: Basic shell commands,  Up: Top

Argument completion
*******************

   This module provides a programmable completion function bound to the
TAB key, which allows for completing command names, file names,
variable names, arguments, etc.

   Eshell, by using the pcomplete package, provides a full programmable
completion facility that is comparable to shells like tcsh or zsh.

   Completions are context-sensitive, which means that pressing `TAB'
after the command `rmdir' will result in a list of directories, while
doing so after `rm' will result in a list of all file entries.

   Many builtin completion rules are provided, for commands such as
`cvs', or RedHat's `rpm' utility.  Adding new completion rules is no
more difficult than writing a plain Lisp functions, and they can be
debugged, profiled, and compiled using exactly the same facilities
(since in fact, they *are* just Lisp functions).  See the definition of
the function `pcomplete/make' for an example of how to write a
completion function.

   The completion facility is very easy to use.  Just press TAB.  If
there are a large number of possible completions, a buffer will
appearing showing a list of them.  Completions may be selected from
that buffer using the mouse.  If no completion is selected, and the
user starts doing something else, the display buffer will automatically
disappear.

   If the list of possible completions is very small, Eshell will
"cycle" through them, selecting a different entry each time `TAB' is
pressed.  `S-TAB' may be used to cycle in the opposite direction.

   Glob patterns can also be cycled.  For example, entering `echo
x*<tab>' will cycle through all the filenames beginning with `x'.  This
is done because the glob list is treated as though it were a list of
possible completions.  Pressing `C-c SPC' will insert all of the
matching glob patterns at point.

   If a Lisp form is being entered, `TAB' will complete the Lisp symbol
name, in exactly the same way that `M-TAB' does in Emacs Lisp mode.

   The list of possible completions can be viewed at any point by
pressing `M-?'.

   Finally, context-related help can be accessed by pressing `C-c i'.
This only works well if the completion function has provided Eshell
with sufficient pointers to locate the relevant help text.

 - User Option: eshell-show-lisp-completions
     If non-nil, include Lisp functions in the command completion list.
     If this variable is nil, Lisp completion can still be done in
     command position by using M-TAB instead of TAB.

 - User Option: eshell-show-lisp-alternatives
     If non-nil, and no other completions found, show Lisp functions.
     Setting this variable means nothing if
     `eshell-show-lisp-completions' is non-nil.

 - User Option: eshell-no-completion-during-jobs
     If non-nil, don't allow completion while a process is running.

 - User Option: eshell-command-completions-alist
     An alist that defines simple argument type correlations.  This is
     provided for common commands, as a simplistic alternative to
     writing a completion function.

 - User Option: eshell-cmpl-file-ignore
     A regexp of filenames to be disregarded during file completion.

 - User Option: eshell-cmpl-dir-ignore
     A regexp of names to be disregarded during directory completion.

 - User Option: eshell-cmpl-ignore-case
     If non-nil, ignore case when doing filename completion.

 - User Option: eshell-cmpl-autolist
     If non-nil, automatically list possibilities on partial completion.
     This mirrors the optional behavior of tcsh.

 - User Option: eshell-cmpl-suffix-list
     A list of characters which constitute a proper suffix.

 - User Option: eshell-cmpl-recexact
     If non-nil, use shortest completion if characters cannot be added.
     This mirrors the optional behavior of tcsh.

     A non-nil value is useful if `pcomplete-autolist' is non-nil too.

 - User Option: eshell-cmpl-man-function
     A function to that will be called to display a manual page.  It
     will be passed the name of the command to document.

 - User Option: eshell-cmpl-compare-entry-function
     This function is used to order file entries for completion.  The
     behavior of most all shells is to sort alphabetically.

 - User Option: eshell-cmpl-expand-before-complete
     If non-nil, expand the current argument before completing it.
     This means that typing something such as `$HOME/bi' followed by
     M-x pcomplete-argument will cause the variable reference to be
     resolved first, and the resultant value that will be completed
     against to be inserted in the buffer.  Note that exactly what gets
     expanded and how is entirely up to the behavior of the
     `pcomplete-parse-arguments-function'.

 - User Option: eshell-cmpl-cycle-completions
     If non-nil, hitting the TAB key cycles through the completion list.
     Typical Emacs behavior is to complete as much as possible, then
     pause waiting for further input.  Then if TAB is hit again, show a
     list of possible completions.  When `pcomplete-cycle-completions'
     is non-nil, it acts more like zsh or 4nt, showing the first
     maximal match first, followed by any further matches on each
     subsequent pressing of the TAB key.  M-x pcomplete-list is the key
     to press if the user wants to see the list of possible completions.

 - User Option: eshell-cmpl-cycle-cutoff-length
     If the number of completions is greater than this, don't cycle.
     This variable is a compromise between the traditional Emacs style
     of completion, and the "cycling" style.  Basically, if there are
     more than this number of completions possible, don't automatically
     pick the first one and then expect the user to press TAB to cycle
     through them.  Typically, when there are a large number of
     completion possibilities, the user wants to see them in a list
     buffer so that they can know what options are available.  But if
     the list is small, it means the user has already entered enough
     input to disambiguate most of the possibilities, and therefore
     they are probably most interested in cycling through the
     candidates.  Set this value to nil if you want cycling to always
     be enabled.

 - User Option: eshell-cmpl-restore-window-delay
     The number of seconds to wait before restoring completion windows.
     Once the completion window has been displayed, if the user then
     goes on to type something else, that completion window will be
     removed from the display (actually, the original window
     configuration before it was displayed will be restored), after
     this many seconds of idle time.  If set to nil, completion windows
     will be left on second until the user removes them manually.  If
     set to 0, they will disappear immediately after the user enters a
     key other than TAB.

 - User Option: eshell-command-completion-function
     Function called for completing the initial command argument.

 - User Option: eshell-cmpl-command-name-function
     Function called for determining the current command name.

 - User Option: eshell-default-completion-function
     Function called when no completion rule can be found.  This
     function is used to generate completions for every argument.


File: eshell.info,  Node: Directory navigation,  Next: Extended filename globbing,  Prev: Argument completion,  Up: Top

Directory navigation
********************

   Directory navigation involves changing directories, examining the
current directory, maintaining a directory stack, and also keeping
track of a history of the last directory locations the user was in.
Emacs does provide standard Lisp definitions of `pwd' and `cd', but
they lack somewhat in feel from the typical shell equivalents.

   The only special feature that Eshell offers in the last-dir-ring.
To view the ring, enter:

     cd =

   Changing to an index within the ring is done using:

     cd -      ; same as cd -0
     cd -4

   Or, it is possible to change the first member in the ring which
matches a regexp:

     cd =bcc   ; change to the last directory visited containing "bcc"

   This ring is maintained automatically, and is persisted across
Eshell sessions.  It is a separate mechanism from `pushd' and `popd',
and the two may be used at the same time.

 - User Option: eshell-pwd-convert-function
     The function used to normalize the value of Eshell's `pwd'.  The
     value returned by `pwd' is also used when recording the
     last-visited directory in the last-dir-ring, so it will affect the
     form of the list used by `cd ='.

 - User Option: eshell-ask-to-save-last-dir
     Determine if the last-dir-ring should be automatically saved.  The
     last-dir-ring is always preserved when exiting an Eshell buffer.
     However, when Emacs is being shut down, this variable determines
     whether to prompt the user, or just save the ring.  If set to nil,
     it means never ask whether to save the last-dir-ring.  If set to
     t, always ask if any Eshell buffers are open at exit time.  If set
     to `always', the list-dir-ring will always be saved, silently.

 - User Option: eshell-cd-shows-directory
     If non-nil, using `cd' will report the directory it changes to.

 - User Option: eshell-cd-on-directory
     If non-nil, do a cd if a directory is in command position.

 - User Option: eshell-directory-change-hook
     A hook to run when the current directory changes.

 - User Option: eshell-list-files-after-cd
     If non-nil, call "ls" with any remaining args after doing a cd.
     This is provided for convenience, since the same effect is easily
     achieved by adding a function to `eshell-directory-change-hook'
     that calls "ls" and references `eshell-last-arguments'.

 - User Option: eshell-pushd-tohome
     If non-nil, make pushd with no arg behave as `pushd ~' (like `cd').
     This mirrors the optional behavior of tcsh.

 - User Option: eshell-pushd-dextract
     If non-nil, make "pushd +n" pop the nth dir to the stack top.
     This mirrors the optional behavior of tcsh.

 - User Option: eshell-pushd-dunique
     If non-nil, make pushd only add unique directories to the stack.
     This mirrors the optional behavior of tcsh.

 - User Option: eshell-dirtrack-verbose
     If non-nil, show the directory stack following directory change.
     This is effective only if directory tracking is enabled.

 - User Option: eshell-last-dir-ring-file-name
     If non-nil, name of the file to read/write the last-dir-ring.  See
     also `eshell-read-last-dir-ring' and `eshell-write-last-dir-ring'.
     If it is nil, the last-dir-ring will not be written to disk.

 - User Option: eshell-last-dir-ring-size
     If non-nil, the size of the directory history ring.  This ring is
     added to every time `cd' or `pushd' is used.  It simply stores the
     most recent directory locations Eshell has been in.  To return to
     the most recent entry, use `cd -' (equivalent to `cd -0').  To
     return to an older entry, use `cd -N', where N is an integer less
     than `eshell-last-dir-ring-size'.  To return to the last directory
     matching a particular regexp, use `cd =REGEXP'.  To display the
     directory history list, use `cd ='.

     This mechanism is very similar to that provided by `pushd', except
     it's far more automatic.  `pushd' allows the user to decide which
     directories gets pushed, and its size is unlimited.

     `eshell-last-dir-ring' is meant for users who don't use `pushd'
     explicity very much, but every once in a while would like to
     return to a previously visited directory without having to type in
     the whole thing again.

 - User Option: eshell-last-dir-unique
     If non-nil, `eshell-last-dir-ring' contains only unique entries.


File: eshell.info,  Node: Extended filename globbing,  Next: History list management,  Prev: Directory navigation,  Up: Top

Extended filename globbing
**************************

   This module provides extended globbing syntax, similar what is used
by zsh for filename generation.

   The globbing code used by Eshell closely follows the syntax used by
zsh.  Basically, here is a summary of examples:

     echo a*       ; anything starting with 'a'
     echo a#b      ; zero or more 'a's, then 'b'
     echo a##b     ; one or more 'a's, then 'b'
     echo a?       ; a followed by any character
     echo a*~ab    ; 'a', then anything, but not 'ab'
     echo c*~*~    ; all files beginning with 'c', except backups (*~)

   Recursive globbing is also supported:

     echo **/*.c   ; all '.c' files at or under current directory
     echo ***/*.c  ; same as above, but traverse symbolic links

   Using argument predication, the recursive globbing syntax is
sufficient to replace the use of `find expr | xargs cmd' in most cases.
For example, to change the readership of all files belonging to
`johnw' in the `/tmp' directory or lower, use:

     chmod go-r /tmp/**/*(u'johnw')

   The glob above matches all of the files beneath `/tmp' that are
owned by the user `johnw'.  See *Note Value modifiers and predicates::,
for more information about argument predication.

 - User Option: eshell-glob-include-dot-files
     If non-nil, glob patterns will match files beginning with a dot.

 - User Option: eshell-glob-include-dot-dot
     If non-nil, glob patterns that match dots will match . and ..

 - User Option: eshell-glob-case-insensitive
     If non-nil, glob pattern matching will ignore case.

 - User Option: eshell-glob-show-progress
     If non-nil, display progress messages during a recursive glob.

 - User Option: eshell-error-if-no-glob
     If non-nil, it is an error for a glob pattern not to match.   This
     mimcs the behavior of zsh if non-nil, but bash if nil.

 - User Option: eshell-glob-chars-list
     List of additional characters used in extended globbing.

 - User Option: eshell-glob-translate-alist
     An alist for translation of extended globbing characters.


File: eshell.info,  Node: History list management,  Next: Implementation of `ls' in Lisp,  Prev: Extended filename globbing,  Up: Top

History list management
***********************

   This module provides command history management.

   Eshell's history facility imitates the syntax used by bash
([(bash)History Interaction]).  Thus:

     !ls           ; repeat the last command beginning with 'ls'
     !?ls          ; repeat the last command containing ls
     echo !ls:2    ; echo the second arg of the last 'ls' command
     !ls<tab>      ; complete against all possible words in this
                   ; position, by looking at the history list
     !ls<C-c SPC>  ; expand any matching history input at point

   Also, most of `comint-mode's keybindings are accepted:

     M-r     ; search backward for a previous command by regexp
     M-s     ; search forward for a previous command by regexp
     M-p     ; access the last command entered, repeatable
     M-n     ; access the first command entered, repeatable

     C-c M-r ; using current input, find a matching command thus, with
             ; 'ls' as the current input, it will go back to the same
             ; command that '!ls' would have selected
     C-c M-s ; same, but in reverse order

   Note that some of these keybindings are only available if the
`eshell-rebind' is not in use, in which case M-p does what C-c M-r
normally would do, and C-p is used instead of M-p.  It may seem
confusing, but the intention is to make the most useful functionality
the most easily accessible.  If `eshell-rebind' is not being used,
history navigation will use comint's keybindings; if it is, history
navigation tries to use similar keybindings to bash.  This is all
configurable, of course.


File: eshell.info,  Node: Implementation of `ls' in Lisp,  Next: Value modifiers and predicates,  Prev: History list management,  Up: Top

Implementation of `ls' in Lisp
******************************

   This module implements the "ls" utility fully in Lisp.  If it is
passed any unrecognized command switches, it will revert to the
operating system's version.  This version of "ls" uses text properties
to colorize its output based on the setting of `eshell-ls-use-colors'.

   Most of the command switches recognized by GNU's ls utility are
supported ([(fileutils)ls invocation]).

 - User Option: eshell-ls-unload-hook
     When unloading `eshell-ls', restore the definition of
     `insert-directory'.

 - User Option: eshell-ls-use-in-dired
     If non-nil, use `eshell-ls' to read directories in dired.

 - User Option: eshell-ls-default-blocksize
     The default blocksize to use when display file sizes with -s.

 - User Option: eshell-ls-exclude-regexp
     Unless -a is specified, files matching this regexp will not be
     shown.

 - User Option: eshell-ls-use-colors
     If non-nil, use colors in file listings.

 - User Option: eshell-ls-archive-regexp
     A regular expression that matches names of file archives.  This
     typically includes both traditional archives and compressed files.

 - User Option: eshell-ls-backup-regexp
     A regular expression that matches names of backup files.

 - User Option: eshell-ls-product-regexp
     A regular expression that matches names of product files.
     Products are files that get generated from a source file, and hence
     ought to be recreatable if they are deleted.

 - User Option: eshell-ls-clutter-regexp
     A regular expression that matches names of junk files.  These are
     mainly files that get created for various reasons, but don't
     really need to stick around for very long.

 - User Option: eshell-ls-highlight-alist
     This alist correlates test functions to color.  The format of the
     members of this alist is

          (TEST-SEXP . FACE)

     If TEST-SEXP evals to non-nil, that face will be used to highlight
     the name of the file.  The first match wins.  `file' and `attrs'
     are in scope during the evaluation of TEST-SEXP.


File: eshell.info,  Node: Value modifiers and predicates,  Next: Command prompts,  Prev: Implementation of `ls' in Lisp,  Up: Top

Value modifiers and predicates
******************************

   This module allows for predicates to be applied to globbing patterns
(similar to zsh), in addition to string modifiers which can be applied
either to globbing results, variable references, or just ordinary
strings.

   Argument predication is used to affect which members of a list are
selected for use as argument.  This is most useful with globbing, but
can be used on any list argument, to select certain members.

   Argument modifiers are used to manipulate argument values.  For
example, sorting lists, upcasing words, substituting characters, etc.

   Here are some examples of how to use argument predication.  Most of
the predicates and modifiers are modeled after those provided by zsh.

     ls -ld *(/)           ; list all directories
     ls -l *(@u'johnw')    ; list all symlinks owned by 'johnw'
     bzip2 -9v **/*(a+30)  ; compress everything which hasn't been
                             accessed in 30 days
     echo *.c(:o:R)     ; a reversed, sorted list of C files
     *(^@:U^u0)         ; all non-symlinks not owned by 'root', upcased
     chmod u-x *(U*)    : remove exec bit on all executables owned by user

   See the zsh docs for more on the syntax ([(zsh.info)Filename
Generation]).

 - User Option: eshell-predicate-alist
     A list of predicates than can be applied to a globbing pattern.
     The format of each entry is

          (CHAR . PREDICATE-FUNC-SEXP)

 - User Option: eshell-modifier-alist
     A list of modifiers than can be applied to an argument expansion.
     The format of each entry is

          (CHAR ENTRYWISE-P MODIFIER-FUNC-SEXP)


File: eshell.info,  Node: Command prompts,  Next: Rebind keys at input,  Prev: Value modifiers and predicates,  Up: Top

Command prompts
***************

   This module provides command prompts, and navigation between them,
as is common with most shells.

   Most of the prompt navigation commands of `comint-mode' are
supported, such as C-c C-n, C-c C-p, etc.

 - User Option: eshell-prompt-function
     A function that returns the Eshell prompt string.  Make sure to
     update `eshell-prompt-regexp' so that it will match your prompt.

 - User Option: eshell-prompt-regexp
     A regexp which fully matches your eshell prompt.  This setting is
     important, since it affects how eshell will interpret the lines
     that are passed to it.  If this variable is changed, all Eshell
     buffers must be exited and re-entered for it to take effect.

 - User Option: eshell-highlight-prompt
     If non-nil, Eshell should highlight the prompt.

 - User Option: eshell-before-prompt-hook
     A list of functions to call before outputting the prompt.

 - User Option: eshell-after-prompt-hook
     A list of functions to call after outputting the prompt.  Note
     that if `eshell-scroll-show-maximum-output' is non-nil, then
     setting `eshell-show-maximum-output' here won't do much.  It
     depends on whether the user wants the resizing to happen while
     output is arriving, or after.


File: eshell.info,  Node: Rebind keys at input,  Next: Running script files.,  Prev: Command prompts,  Up: Top

Rebind keys at input
********************

   This module allows for special keybindings that only take effect
while the point is in a region of input text.  By default, it binds C-a
to move to the beginning of the input text (rather than just the
beginning of the line), and C-p and C-n to move through the input
history, C-u kills the current input text, etc.  It also, if
`eshell-confine-point-to-input' is non-nil, does not allow certain
commands to cause the point to leave the input area, such as
`backward-word', `previous-line', etc.  This module intends to mimic
the behavior of normal shells while the user editing new input text.

   User Variables:

 - User Option: eshell-rebind-keys-alist
     Bind some keys differently if point is in input text.

 - User Option: eshell-confine-point-to-input
     If non-nil, do not allow the point to leave the current input.
     This is more difficult to do nicely in Emacs than one might think.
     Basically, the `point-left' attribute is added to the input text,
     and a function is placed on that hook to take the point back to
     `eshell-last-output-end' every time the user tries to move away.
     But since there are many cases in which the point _ought_ to move
     away (for programmatic reasons), the variable
     `eshell-cannot-leave-input-list' defines commands which are
     affected from this rule.  However, this list is by no means as
     complete as it probably should be, so basically all one can hope
     for is that other people will left the point alone in the Eshell
     buffer.  Sigh.

 - User Option: eshell-error-if-move-away
     If non-nil, consider it an error to try to move outside current
     input.  This is default behavior of shells like bash.

 - User Option: eshell-remap-previous-input
     If non-nil, remap input keybindings on previous prompts as well.

 - User Option: eshell-cannot-leave-input-list
     A list of commands that cannot leave the input area.


File: eshell.info,  Node: Running script files.,  Next: Smart display of output,  Prev: Rebind keys at input,  Up: Top

Running script files.
*********************

   This module allows for the execution of files containing Eshell
commands, as a script file.

   User Variables:

 - User Option: eshell-login-script
     If non-nil, a file to invoke when starting up Eshell interactively.
     This file should be a file containing Eshell commands, where
     comment lines begin with `#'.

 - User Option: eshell-rc-script
     If non-nil, a file to invoke whenever Eshell is started.  This
     includes when running `eshell-command'.


File: eshell.info,  Node: Smart display of output,  Next: Running visual commands,  Prev: Running script files.,  Up: Top

Smart display of output
***********************

   This module combines the facility of normal, modern shells with some
of the edit/review concepts inherent in the design of Plan 9's 9term.
See the docs for more details.

   Most likely you will have to turn this option on and play around with
it to get a real sense of how it works.

   The best way to get a sense of what this code is trying to do is by
using it.  Basically, the philosophy represents a blend between the
ease of use of modern day shells, and the review-before-you-proceed
mentality of Plan 9's 9term.

   * When you invoke a command, it is assumed that you want to read the
     output of that command.

   * If the output is not what you wanted, it is assumed that you will
     want to edit, and then resubmit a refined version of that command.

   * If the output is valid, pressing any self-inserting character key
     will jump to end of the buffer and insert that character, in order
     to begin entry of a new command.

   * If you show an intention to edit the previous command--by moving
     around within it--then the next self-inserting characters will
     insert *there*, instead of at the bottom of the buffer.

   * If you show an intention to review old commands, such as M-p or
     M-r, point will jump to the bottom of the buffer before invoking
     that command.

   * If none of the above has happened yet (i.e., your point is just
     sitting on the previous command), you can use SPACE and BACKSPACE
     (or DELETE) to page forward and backward *through the output of
     the last command only*.  It will constrain the movement of the
     point and window so that the maximum amount of output is always
     displayed at all times.

   * While output is being generated from a command, the window will be
     constantly reconfigured (until it would otherwise make no
     difference) in order to always show you the most output from the
     command possible.  This happens if you change window sizes,
     scroll, etc.

   * Like I said, it's not really comprehensible until you try it! ;)

 - User Option: eshell-smart-unload-hook
     A hook that gets run when `eshell-smart' is unloaded.

 - User Option: eshell-review-quick-commands
     If nil, point does not stay on quick commands.  A quick command is
     one that produces no output, and exits successfully.

 - User Option: eshell-smart-display-navigate-list
     A list of commands which cause Eshell to jump to the end of buffer.

 - User Option: eshell-smart-space-goes-to-end
     If non-nil, space will go to end of buffer when point-max is
     visible.  That is, if a command is running and the user presses
     SPACE at a time when the end of the buffer is visible, point will
     go to the end of the buffer and smart-display will be turned off
     (that is, subsequently pressing backspace will not cause the
     buffer to scroll down).

     This feature is provided to make it very easy to watch the output
     of a long-running command, such as make, where it's more desirable
     to see the output go by than to review it afterward.

     Setting this variable to nil means that space and backspace will
     always have a consistent behavior, which is to move back and forth
     through displayed output.  But it also means that enabling output
     tracking requires the user to manually move point to the end of the
     buffer using \[end-of-buffer].

 - User Option: eshell-where-to-jump
     This variable indicates where point should jump to after a command.
     The options are `begin', `after' or `end'.


File: eshell.info,  Node: Running visual commands,  Next: UNIX commands in Lisp,  Prev: Smart display of output,  Up: Top

Running visual commands
***********************

   This module causes visual commands (e.g., `vi') to be executed by
the `term' package, which comes with Emacs.  This package handles most
of the ANSI control codes, allowing curses-based applications to run
within an Emacs window.  The variable `eshell-visual-commands' defines
which commands are considered visual in nature.

   At the moment, eshell is stream-based in its interactive input and
output.  This means that full-screen commands, such as "vi" or "lynx",
will not display correctly.  These are therefore thought of as "visual"
programs.  In order to run these progrem under Emacs, Eshell uses the
term.el package, and invokes them in a separate buffer, giving the
illusion that Eshell itself is allowing these visual processes to
execute.

 - User Option: eshell-visual-commands
     A list of commands that present their output in a visual fashion.

 - User Option: eshell-term-name
     Name to use for the TERM variable when running visual commands.
     See `term-term-name' in term.el for more information on how this is
     used.

 - User Option: eshell-escape-control-x
     If non-nil, allow `C-x' to be handled by Emacs key in visual
     buffers.  See the variable `eshell-visual-commands'.  If this
     variable is set to nil, `C-x' will send that control character to
     the invoked process.


File: eshell.info,  Node: UNIX commands in Lisp,  Next: Extra alias functions,  Prev: Running visual commands,  Up: Top

UNIX commands in Lisp
*********************

   This module defines many of the more common UNIX utilities as
aliases implemented in Lisp.  These include mv, ln, cp, rm, etc.  If
the user passes arguments which are too complex, or are unrecognized by
the Lisp variant, the external version will be called (if available).
The only reason not to use them would be because they are usually much
slower.  But in several cases their tight integration with Eshell makes
them more versatile than their traditional cousins (such as being able
to use `kill' to kill Eshell background processes by name).

   This file contains implementations of several UNIX command in Emacs
Lisp, for several reasons:

     1) it makes them available on all platforms where the Lisp
        functions used are available

     2) it makes their functionality accessible and modified by the
        Lisp programmer.

     3) it allows Eshell to refrain from having to invoke external
        processes for common operations.

 - User Option: eshell-plain-grep-behavior
     If non-nil, standalone "grep" commands will behave normally.
     Standalone in this context means not redirected, and not on the
     receiving side of a command pipeline.

 - User Option: eshell-no-grep-available
     If non-nil, no grep is available on the current machine.

 - User Option: eshell-plain-diff-behavior
     If non-nil, standalone "diff" commands will behave normally.
     Standalone in this context means not redirected, and not on the
     receiving side of a command pipeline.

 - User Option: eshell-plain-locate-behavior
     If non-nil, standalone "locate" commands will behave normally.
     Standalone in this context means not redirected, and not on the
     receiving side of a command pipeline.

 - User Option: eshell-rm-removes-directories
     If non-nil, `rm' will remove directory entries.  Otherwise,
     `rmdir' is required.

 - User Option: eshell-rm-interactive-query
     If non-nil, `rm' will query before removing anything.

 - User Option: eshell-mv-interactive-query
     If non-nil, `mv' will query before overwriting anything.

 - User Option: eshell-mv-overwrite-files
     If non-nil, `mv' will overwrite files without warning.

 - User Option: eshell-cp-interactive-query
     If non-nil, `cp' will query before overwriting anything.

 - User Option: eshell-cp-overwrite-files
     If non-nil, `cp' will overwrite files without warning.

 - User Option: eshell-ln-interactive-query
     If non-nil, `ln' will query before overwriting anything.

 - User Option: eshell-ln-overwrite-files
     If non-nil, `ln' will overwrite files without warning.


File: eshell.info,  Node: Extra alias functions,  Prev: UNIX commands in Lisp,  Up: Top

Extra alias functions
*********************

   This module defines some extra alias functions which are entirely
optional.  They can be viewed as samples for how to write Eshell alias
functions, or as aliases which make some of Emacs' behavior more
naturally accessible within Emacs.



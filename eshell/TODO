-*- mode: text; outline-layout: (-1 :) -*-

* grep python $<rpm -qa> doesn't work, but using *grep does

* problem with C-r repeating text

If the text at cursor reads "./run", and I then type C-r r u n, it
will repeat the line for every character in the line that I type.

* hitting space during a process invocation, such as make, will cause
  it to track the bottom of the output; but backspace no longer
  scrolls back

* it's not possible to fully unload-feature Eshell at the moment

* put menu support back in

* Emacs 21: Using C-p and C-n with rebind gets into a locked state

I need a reproducible case for this one

* If an interactive process is currently running, M-! doesn't work

* Emacs 21: Screen flickers while a process is running

* Use a timer instead of `sleep-for' when killing child processes

* add a crude input piping facility

So that the Lisp command on the right of the pipe is repeatedly called
with the input strings as arguments.  This will require changing
eshell-do-pipeline to handle non-process targets.

* problem running "less" without argument on Windows

Before running telnet, I noticed that 'less' (for example) was already
configured as a visual command. So I invoked it from eshell to see what
would happen.

Here's the result in the eshell buffer:

	Spawning child process: invalid argument

Also a new 'less' buffer was created with nothing in it .. (presumably this
holds the output of less)

If I run 'less.exe' from the eshell command line, I get the output I expect
simply written to the buffer.

Note that I'm using FSF NT-Emacs 20.6.1 on Win2000. The term.el package and
the supplied shell both seem to use the 'cmdproxy' program to run things
like shells.

* implement -r, -n and -s switches for cp

* Make M-5 eshell -> switch to *eshell<5>*, creating it if need be

* mv DIR FILE.tar does not remove directories

This is because the tar option --remove-files doesn't do so.  Should
it be Eshell's job?

* Write an article about Eshell for the LinuxWorld journal.

* bind standard-output and standard-error, so that if a Lisp function
  calls `print', everything will happen as it should (albeit slowly)

* when the extension modules fail to load, cd / gives a Lisp error

* if a globbing patterns returns only one match, should it still be a
  list?

* make sure that the syntax table correctly in eshell mode

So that M-DEL acts in a predictable manner, etc.

* allow all Eshell buffers to share the same history and list-dir

* error with script commands and outputting to /dev/null

If a script file, somewhere in the middle, does a "> /dev/null",
output from all subsequent commands will be swallowed

* split up parsing of the text after a $ in eshell-var

Similar to way that eshell-arg is structured.  Then add parsing of
$[?\n]

* after pressing M-RET, redisplay before running the next command

* argument predicates and modifiers should work anywhere in a path

  /usr/local/src/editors/vim $ vi **/CVS(/)/Root(.)
  Invalid regexp: "Unmatched ( or \\("

with zsh, the glob above expands to all files named Root in
directories named CVS.

* typing "echo ${locate locate}/bin<tab>" results in a Lisp error

Perhaps it should interpolate all permutations, and make that the
globbing result, since otherwise hitting return here will result in
"(list of filenames)/bin", which is never very valuable.  Thus, one
could cat only c backup files by using "ls ${identity *.c}~".  In that
case, having an alias command name `glob' for `identity' would be
useful

* for XEmacs on Win32, fix `file-name-all-completions'

Make sure it returns directory names terminated by
`directory-sep-char' (which is initialized to be ?/), rather than
backslash

* once symbolic mode is supported for umask, implement chmod in Lisp

* create `eshell-expand-file-name'

Which uses a data table to transform things like "~+", "...", etc

* abstract `eshell-smart.el' into `smart-scroll.el'

It only really needs: to be hooked onto the output filter and the
pre-command hook, and to have the input-end and input-start markers.
And to know whether the last output group was "successful".

* allow for fully persisting the state of Eshell

vars, history, buffer, input, dir stack, etc.

* implement D in the predicate list

It means that files beginning with a dot should be included in the
glob match

* a comma in a predicate list means OR

* error if a glob doesn't expand due to a predicate

An error should be generated only if `eshell-error-if-no-glob' is
non-nil

* the following doesn't cause an indent-according-to-mode to occur

(+ RET SPC TAB

* create `eshell-auto-accumulate-list'

It is a list of commands for which, if the user presses RET, the text
gets staged as the next Eshell command, rather than being sent to the
current interactive

* display file and line number if an error occurs in a script

* wait doesn't work with process ids at the moment

* enable the direct-to-process input code in eshell-term.el

* problem with repeating "echo ${find /tmp}"

With smart display active, if I hold down RET, after a while it can't
keep up anymore and starts outputting blank lines.  It only happens if
an asynchronous process is involved...

I think the problem is that `eshell-send-input' is resetting the input
target location, so that if the asynchronous process is not done by
the time the next RET is received, the input processor thinks that the
input is meant for the process; which, because smart display is
enabled, will be the text of the last command line!  That is a bug in
itself.

In holding down RET while an asynchronous process is running, there
will be a point in between termination of the process, and the running
of eshell-post-command-hook, which would cause `eshell-send-input' to
call `eshell-copy-old-input', and then process that text as a command
to be run after the process.  Perhaps there should be a way of killing
pending input between the death of the process, and the
post-command-hook.

* allow for a more aggressive smart display mode

Perhaps toggled by a command, that makes each output block a smart
display block

* create more meta variables

$! -- the reason for the failure of the last disk command, or the text
      of the last Lisp error

$= -- a special associate array, which can take references of the form
      $=[REGEXP].  It also indexes into the directory ring

* eshell scripts can't execute in the background

* support zsh's "Parameter Expansion" syntax, i.e. ${NAME:-VAL}

* write an `info' alias that can take arguments

So that the user can enter "info chmod"

* split off more generic code from Eshell

. + parse-args.el --- parse a list of arguments
. + interpolate.el --- interpolate $variable $(lisp)... references
. + interp.el --- find which interpretor to run a script with
. + sh-ring.el --- extend ring.el for persistant, searchable history
. + zsh-glob.el --- zsh-style globbing and predicate/modifiers
. + smartdisp.el --- smart scrolling in input buffers
. + egetopt.el --- `eshell-eval-using-options'
. + prompt.el --- code for outputting and navigating prompts
. + cmd-rebind.el --- rebind certain keys in the input text
. + unix.el --- provides Lispish UNIX command, such as unix-rm, etc.
. + emacs-ls.el --- implementation of ls in Emacs Lisp
. + texidoc.el
. + pushd.el --- implementation of pushd/popd in Lisp
. + interface.el -- a mode for reading command-line input from the user

* create a mode `eshell-browse'

It would treat the Eshell buffer as a outline.  Collapsing the outline
hides all of the output text.  Collapsing again would show only the
first command run in each directory

* look through the Korn Shell book for feature ideas

* allow other version of a file to be referenced by "file{rev}"

This would be expanded by `eshell-expand-file-name'

* print "You have new mail" when the "Mail" icon gets turned on

* implement M-|

* implement input redirection

If it's a lisp function, input redirection implies "xargs" (in a
way..).  And if input redirection is added, don't forget to update the
file-name-quote-list, and the delimiter list.

* allow #<WORD ARG> to be a generic syntax

With the handling of "word" specified by an `eshell-special-alist'.

* in `eval-using-options', have a :complete tag

It would be used to provide completion rules for that command.  Then
the macro will automagically define the completion function

* for `eshell-command-on-region', redirections apply to the result

So that "+ > 'blah" will cause the result of the `+' (using input from
the current region) to be inserting in the symbol `blah'.

If a disk command is being invoked, the input is sent as standard
input, as if a "cat <region> |" were invoked.

If a lisp command, or an alias, is invoked, then: if the line has no
^J characters, it is divided by whitespace and passed as arguments to
the lisp function.  Otherwise, it is divided at the ^J characters.
Thus, invoking `+' on a series of numbers will add them; `min' would
display the smallest figure.

* write `eshell-script-mode' as a minor mode

It would provide syntax, abbrev, highlighting and indenting support
like emacs-lisp-mode + shell-mode.

* in the history mechanism, finish bash-style support

For !n, !#, !:%, and !:1- as separate from !:1*

* support the -n command line option for "history"

* implement `fc'

* specifying a frame as a redirection target implies point's buffer

* implement ">FUNC-OR-FUNC-LIST"

This would allow for an "output translator", that takes a function to
modify output with, and the target.  Devise a syntax that words well
with pipes, and can accomodate multiple functions (i.e.,">'(upcase
regexp-quote)" or ">'upcase").

* allow Eshell to read/write to/from standard input and output

This would be optional, rather than always using the Eshell buffer.
This would allow it to be run from the command line.

* write a "help" command

It could even call subcommands with "--help" (or "-h" or "/?").

* implement stty

* support rc's matching operator, "~ (list) regexp"

* implement "bg" and "fg" to edit `eshell-process-list'

Using "bg" on a process that is already in the background does
nothing.  Specifying redirection targets replaces (or adds) to the
list current being used.

* have "jobs" print only the processes for the current eshell

* how do I discover that a background process has requested input?

* support 2>&1 and >& and 2> and |&

The syntax table for parsing these should be customizable, such that
the user could change it to use rc syntax: >[2=1].

* allow $_[-1], which reads the last element of the array, etc.

* make $x[*] equal to listing out the full contents of x

Return them as a list, so that $_[*] is all the arguments of the last
command.

* move ANSI code handling from `term' into `eshell-term'

And make it possible for the user to send char-by-char to the
underlying process.  Ultimately, I should be able to move away from
using term.el altogether, since everything but the ANSI code handling
is already part of Eshell.  Then, things would work correctly on Win32
as well (which doesn't have "/bin/sh", though term tries to use it)

* have other shell spawning commands be visual

Make (su, bash, telnet, rlogin, rsh, etc.) be part of
`eshell-visual-commands'.  The only exception is if rsh/su/bash are
simply being used to invoke a single command.  Then, it should be
based on what that command is.

* create an alias "open"

This will search for some way to open its argument (similar to opening
a file in the Windows Explorer).  Perhaps using ffap...

* alias "read" to be the same as "open", except read-only

* write a "tail -f" alias which does a view-file

I.e., it moves point to the end of the buffer, and then turns on
auto-revert mode in that buffer at frequent intervals -- and a head
alias which assums an upper limit of `eshell-maximum-line-length'
characters per line.

* make dgrep load dired, mark everything, then execute the A binding

* write emsh.c

It just runs Emacs with the appropriate arguments to invoke eshell.
That way, it could be listed as a login shell.

* use an intangible PS2 string for multi-line input prompts

* auto-detect when a command is visual, by checking TERMCAP usage

* First keypress after M-x watson triggers `eshell-send-input'

* Emacs 20.3: Figure out why pcomplete won't make

* Make / electric

So that it automatically expands and corrects pathnames.  Or make
pathname completion for pcomplete auto-expand "/u/i/std<TAB>" to
"/usr/include/std<TAB>".

* Write pushd/popd out to disk along with last-dir-ring

* add options to eshell/cat which would cause it to sort and uniq

* implement in Lisp: wc.  Also count sentences, paragraphs, pages.

* once piping is added, implement sort and uniq

* implement touch

* implement epatch

Calls ediff-patch-file, or ediff-patch-buffer, depending on its
argument.

* have an option for bringing up ls -l result in a dired buffer

* write a version of xargs that's based on command rewriting

find X | xargs Y == Y ${find X}.  Maybe I could change
eshell-do-pipelines to perform this on-thy-fly rewriting.

* implement head and tail in Lisp

* write an alias for less and more that brings up a view buffer

Such that they can press SPC and DEL, and then q to return to eshell.
The more command would be equivalent to: X > #<buffer Y>; view-buffer
#<buffer Y>

* differentiate between aliases and functions

Allow for a bash-compatible syntax, such as:

  alias arg=blah
  function arg () { blah $* }

* find the various references to shell-mode within Emacs

And add support for Eshell there, since now Eshell is going to be part
of Emacs.

* permit umask to be set on a cp target during the cp command
